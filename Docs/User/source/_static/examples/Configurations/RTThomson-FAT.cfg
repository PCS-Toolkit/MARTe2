/*
 TCV SCD MARTe2 cfg file
 real-time Thomson scattering acquisition system FAT tester
 TCV
 CGalperti 17.07.20

 - 1 thread, AFHBA404 timing, transient auto termination
 - ADC control scripts DISABLED
 - state machine
 - TCP server for advancing state machine, ShotManager for sending status to MDS+ 
 - MDS+ storage of algorithm outputs and timings
 
 CPUs allocation (spcpc373 layout):
 1 0x01 System (not isolated)
 2 0X02 System (not isolated)
 3 0x04 System (not isolated) + MDSWriter1
 4 0x08 ADC polling + RT Thread 1
 5 
 6
 7
 8
 9
 10
 
 Changelog:
 
 - 17.07.20 CG first written from tcvrt03-1005-FPS
*/

+ShotManager = {
 Class = SPCShotManager
 Server = spcpc171.epfl.ch
 Tree = martetest
 Shot = 1
 Statusnode = ST.CH20
 //AbortScript = "/root/scd/commands/abort-ADC" 
 // The parameter param1 is the shotnumber to be opened 
 //+OpenTreeMsg1 = { Class = Message Destination = RTApp.Data.MDSWriter1 Function = OpenTree Mode = ExpectsReply +Parameters = { Class = ConfigurationDatabase param1 = 0 } } 
 //+OpenTreeMsg2 = { Class = Message Destination = RTApp.Data.MDSWriter2 Function = OpenTree Mode = ExpectsReply +Parameters = { Class = ConfigurationDatabase param1 = 0 } }
}

+TCPMessageProxy = {
    Class = TCPSocketMessageProxyExample
    Port = 24680
}

+StateMachine = {
 Class = StateMachine
 +INITIAL = {
  Class = ReferenceContainer
  +RUN = {
   Class = StateMachineEvent
   NextState = "RUN"
   NextStateError = "ERROR"
   Timeout = 0
   +ChangeToRunMsg               = { Class = Message Destination = RTApp     Function = PrepareNextState Mode = ExpectsReply +Parameters = { Class = ConfigurationDatabase param1 = Run } }
   +StartNextStateExecutionMsg   = { Class = Message Destination = RTApp     Function = StartNextStateExecution Mode = ExpectsReply }
   +ShotManagerStartMsg 	     = { Class = Message Destination = ShotManager Function = Run Mode = ExpectsReply }
  }
  +ERROR = {
   Class = StateMachineEvent
   NextState = "ERROR"
   NextStateError = "ERROR"
   Timeout = 0
   +ShotManagerErrorMsg 	     = { Class = Message Destination = ShotManager Function = Error Mode = ExpectsReply }  
  }
  +EXIT = {
   Class = StateMachineEvent
   NextState = "FINAL"
   NextStateError = "ERROR"
   Timeout = 0
   +ExitAppMsg = { Class = Message Destination = ShotManager     Function = Exit }   
  }
  +ABORT = {
   Class = StateMachineEvent
   NextState = "FINAL"
   NextStateError = "ERROR"
   Timeout = 0
   +ExitAppMsg = { Class = Message Destination = ShotManager     Function = Exit }   
  }
 }
 +RUN = {
  Class = ReferenceContainer
  +RUNCOMPLETE = {
   Class = StateMachineEvent
   NextState = "ENDRUN"
   NextStateError = "ERROR"
   Timeout = 0
   +StopCurrentStateExecutionMsg = { Class = Message Destination = RTApp     			Function = StopCurrentStateExecution Mode = ExpectsReply }
   +MdsFlushSegmentsMsg1         = { Class = Message Destination = RTApp.Data.MDSWriter1 Function = FlushSegments Mode = ExpectsReply }
   //+MdsFlushSegmentsMsg2         = { Class = Message Destination = RTApp.Data.MDSWriter2 Function = FlushSegments Mode = ExpectsReply }
   +ShotManagerStopMsg 			 = { Class = Message Destination = ShotManager 			Function = Stop Mode = ExpectsReply }
  }
  +ABORT = {
   Class = StateMachineEvent
   NextState = "FINAL"
   NextStateError = "ERROR"
   Timeout = 0
   +StopLLCMsg					   = { Class = Message Destination = RTApp.Data.ADCSystem  Function = StopLLC Mode = ExpectsReply }
   +StopCurrentStateExecutionMsg = { Class = Message Destination = RTApp     			Function = StopCurrentStateExecution Mode = ExpectsReply }
   +ShotManagerAbortMsg 		 = { Class = Message Destination = ShotManager 			Function = Abort Mode = ExpectsReply }
  }
 }
 +ENDRUN = {
  Class = ReferenceContainer
  +ENTER = {
   Class = ReferenceContainer
   //+StopCurrentStateExecutionMsg = { Class = Message Destination = RTApp     Function = StopCurrentStateExecution Mode = ExpectsReply }   
   //+ShotManagerStopMsg 			 = { Class = Message Destination = ShotManager Function = Stop Mode = ExpectsReply }
  }
  +EXIT = {
   Class = StateMachineEvent
   NextState = "FINAL"
   NextStateError = "ERROR"
   Timeout = 0
   +ExitAppMsg = { Class = Message Destination = ShotManager     Function = Exit }   
  }
  +ABORT = {
   Class = StateMachineEvent
   NextState = "FINAL"
   NextStateError = "ERROR"
   Timeout = 0
   +ExitAppMsg = { Class = Message Destination = ShotManager     Function = Exit }   
  }
 } 
 +FINAL = {
  Class = ReferenceContainer
  +FINAL = {
   Class = StateMachineEvent
   NextState = "FINAL"
   NextStateError = "ERROR"
   Timeout = 0   
  } 
 }
 +ERROR = {
  Class = ReferenceContainer  
  +ENTER = {
   Class = ReferenceContainer
   +ShotManagerErrorMsg = { Class = Message Destination = ShotManager     Function = Error Mode = ExpectsReply }   
  }  
  +EXIT = {
   Class = StateMachineEvent
   NextState = "FINAL"
   NextStateError = "ERROR"
   Timeout = 0
   +ExitAppMsg = { Class = Message Destination = ShotManager     Function = Exit }   
  }
 }
}

$RTApp = {
    Class = RealTimeApplication
    +Functions = {
        Class = ReferenceContainer
         
        /********************************************************/
        /* THREAD1                                              */
        /********************************************************/                    
        +ADCBroker = {
            Class = IOGAM
            InputSignals = {
                Counter      = {                   DataSource = ADCSystem Type = int32 NumberOfElements = 4 }                
                Time         = { 				   DataSource = ADCSystem Type = int32 Frequency = 1000 }
            	ADCuscounter = {                   DataSource = ADCSystem Type = uint32 NumberOfElements = 4 }
                ADCinputs    = {                   DataSource = ADCSystem Type = int16 NumberOfElements = 768 NumberOfDimensions = 1 }
            }
            OutputSignals = {
                Counter      = {                   DataSource = DDB1  Type = int32 NumberOfElements = 4 }                
                Time         = {                   DataSource = DDB1  Type = int32 Default = 0 }      
                ADCuscounter = {                   DataSource = DDB1  Type = uint32 NumberOfElements = 4 }
                realadc      = {                   DataSource = DDB1  Type = int16 NumberOfElements = 768 NumberOfDimensions = 1 }   
            }
        }       
        +TimeSignals = {
        	Class = SPCTimeGAM
        	MdsTimeOffset = 0       
			MdsStartTime = 0 
			MdsStopTime = 10000000   			
        	InputSignals = {
        		Time  = { DataSource = DDB1     Type = int32 }
        	}
        	OutputSignals = {
        		realtime         = { DataSource = DDB1 Type = float32     }
				offsettimeforMDS = { DataSource = DDB1 Type = int32       }
				triggerforMDS    = { DataSource = DDB1 Type = uint8       }
        	}
        }     
		+TimingSignalsBroker1 = {
         Class = IOGAM
         InputSignals = { 
         	Thread1_CycleTime    			= { DataSource = Timings Type = uint32 Alias = Run.Thread1_CycleTime }
	        ADCBroker_ReadTime    			= { DataSource = Timings Type = uint32 Default = 0 } 	        
	        ADCBroker_ExecTime    			= { DataSource = Timings Type = uint32 Default = 0 } 
	        ADCBroker_WriteTime    			= { DataSource = Timings Type = uint32 Default = 0 }    
	        StorageBroker1_ReadTime        	= { DataSource = Timings Type = uint32 Default = 0 } 	       
	        StorageBroker1_ExecTime        	= { DataSource = Timings Type = uint32 Default = 0 } 
	        StorageBroker1_WriteTime       	= { DataSource = Timings Type = uint32 Default = 0 } 
         }
         OutputSignals = { 
         	Thread1_CycleTime    			= { DataSource = DDB1 Type = uint32 Default = 0 }     
	        ADCBroker_Time    				= { DataSource = DDB1 Type = uint32 NumberOfElements = 3 } 	        
	        StorageBroker1_Time        		= { DataSource = DDB1 Type = uint32 NumberOfElements = 3 }
         }                                                  
        }                                                   
			
        /********************************************************/
        /* MDS STORAGE THREAD                                   */
        /********************************************************/      			
		+StorageBroker1 = {
		 Class = IOGAM
		 InputSignals = {	           	
            Counter      					= { DataSource = DDB1 Type = int32 NumberOfElements = 4 }                
            Time         					= { DataSource = DDB1 Type = int32 Default = 0 }      
            ADCuscounter 					= { DataSource = DDB1 Type = uint32 NumberOfElements = 4 }
            realadc      					= { DataSource = DDB1 Type = int16 NumberOfElements = 768 NumberOfDimensions = 1 Ranges ={{0,0}} }   
         
         	Thread1_CycleTime    			= { DataSource = DDB1 Type = uint32 }
	        ADCBroker_Time    				= { DataSource = DDB1 Type = uint32 NumberOfElements = 3 } 	        	       	        
	        StorageBroker1_Time        		= { DataSource = DDB1 Type = uint32 NumberOfElements = 3 } 	       
		 }
		 OutputSignals = {
            Counter      					= { DataSource = MDSWriter1 Type = int32 NumberOfElements = 4 }                
            Time         					= { DataSource = MDSWriter1 Type = int32 Default = 0 }      
            ADCuscounter 					= { DataSource = MDSWriter1 Type = uint32 NumberOfElements = 4 }
            realadc      					= { DataSource = MDSWriter1 Type = int16 NumberOfElements = 1 NumberOfDimensions = 1 }   

          	Thread1_CycleTime    			= { DataSource = MDSWriter1 Type = uint32 Default = 0 }
	      	ADCBroker_Time    				= { DataSource = MDSWriter1 Type = uint32 NumberOfElements = 3 } 	        	       	        
	      	StorageBroker1_Time        		= { DataSource = MDSWriter1 Type = uint32 NumberOfElements = 3 }        
		 }
		}
		
		+LoggerBroker = {
		 Class = IOGAM
		 InputSignals = {
                Counter      = {                   DataSource = DDB1  Type = int32 NumberOfElements = 4 }                
                Time         = {                   DataSource = DDB1  Type = int32 }      
                ADCuscounter = {                   DataSource = DDB1  Type = uint32 NumberOfElements = 4 }
                realadc      = {                   DataSource = DDB1  Type = int16 NumberOfElements = 768 NumberOfDimensions = 1 Ranges = {{0,0}} }   
		 }
		 OutputSignals =
		 {
		    Counter 	 = 	{ DataSource = LoggerDataSource Type = int32 NumberOfElements = 4 }
		    Time    	 = 	{ DataSource = LoggerDataSource Type = int32 }
            ADCuscounter =  { DataSource = LoggerDataSource Type = uint32 NumberOfElements = 4 }
            realadc      =  { DataSource = LoggerDataSource Type = int16 NumberOfElements = 1  }   
		 }
		} 
		
    }
    +Data = {
        Class = ReferenceContainer
        DefaultDataSource = DDB1        
        +DDB1 				= { Class = GAMDataSource }
        +LoggerDataSource 	= {	Class = LoggerDataSource }  
        +Timings 			= { Class = TimingDataSource }       
                 
        +ADCSystem = {
 	    	Class = AFHBA404::ACQ2106TSIN
			// TODO: IndependentThread isn't working, thread semaphore not handled by Execute, to be fixed
			ExecutionMode = RealTimeThread //Optional. If not set ExecutionMode = IndependentThread. If ExecutionMode == IndependentThread a thread is spawned to generate the time events. ExecutionMode == RealTimeThread the time is generated in the context of the real-time thread.
		    //ExecutionMode = IndependentThread //Optional. If not set ExecutionMode = IndependentThread. If ExecutionMode == IndependentThread a thread is spawned to generate the time events. ExecutionMode == RealTimeThread the time is generated in the context of the real-time thread.			
			CPUMask = 0x04 //Optional and only relevant if ExecutionMode=IndependentThread
     		Cycles = 1000
     		StartTimeUsec = 0
     		//StartTimeUsec = 0
     		// Frequency = 50000
     		// This script is called upon entering run state, after having put the ADC in LLC mode
     		// it arms the ADC system end enters a wait trigger state
     		// CAUTION: in reprocessing the soft-trigger comes too early, for now
     		// arming must be done externally w.r.t. MARTe and the following line commented out
     		// CAUTION: the number of transient samples (samples after which the ADC goes back in idle state) is set in this script
     		//RunScript = "/root/scd/commands/arm-ADC" 
     		//EndrunScript = "/root/scd/commands/checkstop-ADC"
     		Signals = {
         		Counter = { // the sample (event in this case) counters from each ADC system
             		Type = int32
             		NumberOfElements = 4
         		}
         		Time = {    // the realtime maintained by the ADC subsystem, units [us]
             		Type = int32
             		Frequency = 1000 // Dummy data, here only to ask a synchronizing data broker to the framework
         		}
         		ADCuscounter = { // the sample (event in this case) timestamps from each ADC system [us]
         		    Type = uint32
         		    NumberOfElements = 4
         		}
         		ADCinputs = { // ADC inputs vector
             		Type = int16
             		NumberOfElements = 768
         		}
         	}
         	+TermMessage1 = { Class=Message Destination=StateMachine Function=RUNCOMPLETE }
     	}    
        +MDSWriter1 = {
        	Class = MDSWriter
			NumberOfBuffers = 100000
        	CPUMask = 0x04
        	StackSize = 10000000
        	TreeName = "martetest"
        	//StoreOnTrigger = 1
        	StoreOnTrigger = 0        	
        	Verbosity = 2
                
        	// Undefined, OpenTree is deferred, it is performed in response to a specific message sent by the ShotManager
        	// this is necessary because we need a late opening to have simulink buses configured
        	// the shotno is the parameter of the opening message
        	//PulseNumber = -2
        	PulseNumber = -1
          	
        	EventName = "updatejScope"
        	TimeRefresh = 5
        	NumberOfPreTriggers = 0
			NumberOfPostTriggers = 0
		
			Signals = {


//				Trigger 					= { Type = uint8 }	
//			    Time    					= { Type = int32 TimeSignal = 1 TimeSignalMultiplier = 1e-6 }
  
				Thread1_CycleTime    		= { NodeName = "ST.CH01" 	 	 Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 1 SamplePhase = 0 } 
				ADCBroker_Time    			= { NodeName = "ST.CH02" 	 	 Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 3 SamplePhase = 0 } 				
				StorageBroker1_Time        	= { NodeName = "ST.CH03" 	 	 Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 3 SamplePhase = 0 }				
	
				Counter 					= { NodeName = "ST.CH10" 	 	 Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 4 SamplePhase = 0 } 
				Time 						= { NodeName = "ST.CH11" 	 	 Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 1 SamplePhase = 0 } 
				ADCuscounter 				= { NodeName = "ST.CH12" 	 	 Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 4 SamplePhase = 0 } 

//				realadc      				= { NodeName = "AI.CH_%03d" 	 Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 768 SamplePhase = 0 Indexed = 1 } // Plain indexed entry (no multidimensional signal supported!)    	
				realadc      				= { NodeName = "AI.CH001" 	     Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 1 SamplePhase = 0 } // Plain indexed entry (no multidimensional signal supported!)    	

        	}
        	+TreeFlushedMsg = { Class = Message Destination = ShotManager Function = TreeFlushed Mode = ExpectsReply }
        }                      
    }
    +States = {
        Class = ReferenceContainer
        +Run = {
            Class = RealTimeState
            +Threads = {
                Class = ReferenceContainer
                +Thread1 = {
                    Class = RealTimeThread CPUs = 0x08 Functions = {
                      ADCBroker 
                      TimeSignals 
					  TimingSignalsBroker1
					  //LoggerBroker
					  StorageBroker1
                    }                                
                }                
            }
        }
                
    }
    +Scheduler = {
        Class = GAMScheduler
        TimingDataSource = Timings
    }
}
