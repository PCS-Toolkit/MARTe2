/*
 RFM2g synchslave tester 
 CGalperti 10.11.2019

 - RFM2g DataSource in slave mode synchronizing the real-time thread
*/

+TCPMessageProxy = {
    Class = TCPSocketMessageProxyExample
    Port = 24680
}

$RTApp = {
    Class = RealTimeApplication
    +Functions = {
        Class = ReferenceContainer
        
        +RFM = {
            Class = IOGAM
            InputSignals = {
                Counter 	= {               DataSource = RFM Type = int32 }                
                Time    	= { Frequency = 1 DataSource = RFM Type = int32 }
        		InputBuffer = {               DataSource = RFM Type = uint8 NumberOfElements = 388 }
            }
            OutputSignals = {
                Counter =   {                 DataSource = DDB1 Type = int32 }                
                Time =      {                 DataSource = DDB1 Type = int32 }            
		 		RFMdata1 =  {                 DataSource = DDB1 Type = int32 }
		 		adcin =     {                 DataSource = DDB1 Type = int16 NumberOfElements = 192 }                          
            }
        }
 
        +TestSignals1 = {
        	Class = HelperGAM1
        	        	
        	MdsTimeOffset = 0
        	MdsStartTime = -4495000
        	MdsStopTime = 3950000
        	
        	InputSignals = { 
        		Time  = 		{ DataSource = DDB1     Type = int32 }
        	}
        	OutputSignals = {
				realtime			= { DataSource = DDB1 Type = float32  NumberOfElements = 1   }   	
            	adc  				= { DataSource = DDB1 Type = int16    NumberOfElements = 192 }
				rfm_in      		= { DataSource = DDB1 Type = uint8    NumberOfElements = 664 }
				wavegen     		= { DataSource = DDB1 Type = float32  NumberOfElements = 62  }
				proc_in     		= { DataSource = DDB1 Type = float32  NumberOfElements = 3  }
				offsettimeforMDS	= { DataSource = DDB1 Type = int32 	  NumberOfElements = 1 }
		  		triggerforMDS 		= { DataSource = DDB1 Type = uint8    NumberOfElements = 1 }
                DOs 				= { DataSource = DDB1 Type = uint8    NumberOfElements = 4 }
                PWMduty 			= { DataSource = DDB1 Type = uint16   NumberOfElements = 8 } 
        	}
        }        
        
        +LoggerBroker = {
		 Class = IOGAM
		 InputSignals = {
		 	Counter = 		{ DataSource = DDB1 Type = int32 }
		 	//Time    = 		{ DataSource = DDB1 Type = int32 }
		 	RFMdata1 =      { DataSource = DDB1 Type = int32 }
		 }
		 OutputSignals =
		 {
		    Counter-toMaster   =      { DataSource = LoggerDataSource Type = int32 }
		    //Time               = 	  { DataSource = LoggerDataSource Type = int32 }
		    Counter-fromMaster =      { DataSource = LoggerDataSource Type = int32 }
		 }
        } 
        
        +RFMOutputBroker = {
            Class = IOGAM
            InputSignals = {
		    	Counter         = { 		DataSource = DDB1  Type = int32 }
		    	adc  			= { 		DataSource = DDB1 Type = int16    NumberOfElements = 192 }
		    }
		    OutputSignals = {
		        OutputBuffer    = { 		DataSource = RFM  Type = uint8 NumberOfElements = 388 }		    
		    }        
        }       
        
    }
    +Data = {
        Class = ReferenceContainer
        DefaultDataSource = DDB1
        +DDB1 = {
            Class = GAMDataSource
       	}        
        +LoggerDataSource = {
            Class = LoggerDataSource
        }
                
        +Timings = {
            Class = TimingDataSource
        }
          
        +RFM = {
            Class = RFM2g
		    //ExecutionMode = RealTimeThread //Optional. If not set ExecutionMode = IndependentThread. If ExecutionMode == IndependentThread a thread is spawned to generate the time events. ExecutionMode == RealTimeThread the time is generated in the context of the real-time thread.
            ExecutionMode = IndependentThread
            CPUMask = 0x20 //Optional and only relevant if ExecutionMode=IndependentThread
            Device = /dev/rfm2g0 // Mandatory, the Linux device handling the RFM card installed on the system
            
            //ReadOffset = 64 // Mandatory, the offset in bytes of the read starting point in the RF memory
            //WriteOffset = 128 // Mandatory, the offset in bytes of the write starting point in the RF memory
            ReadOffset = 500 // Mandatory, the offset in bytes of the read starting point in the RF memory
            WriteOffset = 64 // Mandatory, the offset in bytes of the write starting point in the RF memory
        
            UseDMA = 1 // Optional, if 1 data exchange will be performed using DMA, if 0 with programmed IO. Default = 0            
            DMABufferAddress = 0x3aec01000 // Required if UseDMA=1, physical address (BEWARE, NOT VIRTUAL, i.e. coming from cat /proc/iomem) of the kernel reserved DMA memory buffer (see node (1))
            WaitDMA = 1 // Required if UseDMA=1, if 0 the DataSource launches DMA read/write transactions without waiting for them to be completed. If 1 it waits for them. (see node (2))
            DMABufferSize = 1024 // The DMA buffer size
            DMAThreshold = 32 // The DMA threshold after which DMA must be used (bytes)
        
            //Synchronizing = 0 // Optional, if 1 the DataSource synchronizes the calling thread using SPC synchronization protocol, if 0 it doesn't synchronize and only exchanges data. Default = 0
            //BasePeriod = 1e-4 // Required if Synchronizing=1, the base period of the RFM synchronization clock (coming from the RFM master mode)
            DownSampleFactor = 10 // Required if Synchronizing=1, the downsample factor for synchronization strobes
            StartTime = 10 // Required if Synchronizing=1, the start time at which the DataSource will begin to synchronize
        
            Master = 0 // Optional, if 1 the node is the RFM synchronizing node, i.e. sends the system time around the RFM ring. Default = 0
        
            //InputEnabled = 1  // To be implemented
            //Outputenabled = 1 // To be implemented
		
		    Signals = {
		        Counter         = { Type = int32 }
                Time            = { Type = int32 Frequency = 1 }
                //Time            = { Type = int32 }                
          		InputBuffer     = { Type = uint8  NumberOfElements = 388 }
		        OutputBuffer    = { Type = uint8  NumberOfElements = 388 }
            }
        }          
    }
    +States = {
        Class = ReferenceContainer
        +Run = {
            Class = RealTimeState
            +Threads = {
                Class = ReferenceContainer
                +Thread1 = {
                    Class = RealTimeThread CPUs = 0x10
                    Functions = {
                     //GAMTimer
                     RFM 
                     //Rename1 
                     //Rename2 
                     TestSignals1
                     RFMOutputBroker 
                     //RFMInputBroker
                     LoggerBroker 
                    }
                }
            }
        }        
    }
    +Scheduler = {
        Class = GAMScheduler
        TimingDataSource = Timings
    }
}
