+MDSParamLoader1 = {
    Class = MDSObjLoader			 // Compulsory
    //Shot = "-1" 				 // Optional if defined in MDSObjConnection
    
    +MDSConnection1 = {
        Class = MDSObjConnection		 // Compulsory
        ClientType = "Thin" //( "Thin" | "Distributed" )  // Optional. Default: "Thin"
        Server = "tcvscd.crpp.tcv:8000"		 // Compulsory if ClientType = "Thin"
        Tree = "martetest"			// Compulsory
        Shot = "10"				  // Optional if defined in MDSObjLoader
 
        +k = { Class = MDSParameter	Path = "k" }
        +ks1 = { Class = MDSParameter	Path = "ks1" }
        +kv1 = { Class = MDSParameter	Path = "kv1" }
        +km1 = { Class = MDSParameter	Path = "km1" }
    
        /*
        +gainStruct-gain_a = {
            Class = MDSParameter				 // Compulsory
            Path  = "\\TREE_NAME::TOP:NODE2"			 // Compulsory
            DataOrientation = ( "RowMajor" | "ColumnMajor" )	 // Only for 2D matrices. Optional. Default: "ColumnMajor"
        }
        +gainStruct-gain_b = {
            Class = MDSParameter				  // Compulsory
            Path  = "\\TREE_NAME::TOP:NODE3"			  // Compulsory
            DataOrientation = ( "RowMajor" | "ColumnMajor" )	  // Only for 2D matrices. Optional. Default: "ColumnMajor"
        }
        */
   }
}

$TestApp = {
    Class = RealTimeApplication
    +Functions = {
        Class = ReferenceContainer
        +GAMTimer = {
            Class = IOGAM
            InputSignals = {
                Counter = { 				DataSource = Timer Type = uint32 }                
                Time 	= { Frequency = 100   DataSource = Timer Type = uint32 }
            }
            OutputSignals = {
                Counter = {                 DataSource = DDB1  Type = uint32 }                
                Time    = {                	DataSource = DDB1  Type = uint32 }            
            }
        }
	    +Constants = {
	     Class = ConstantGAM
	     OutputSignals = {
				input	= { DataSource = DDB1 Type = float32  NumberOfElements = 1  NumberOfDimensions=0 Default=0 }
	     }
	    }
	    +ReaderBroker = {
            Class = IOGAM
            InputSignals = {
                mdsint1 = { DataSource = MDSReader_0 Type = uint32 NumberOfElements = 1 }
                Time    = { DataSource = MDSReader_0 Type = int32  NumberOfElements = 1 }
            }
            OutputSignals = {
                mdsint1      = { DataSource = DDB1 Type = uint32 NumberOfElements = 1 }
                mdsintime    = { DataSource = DDB1 Type = int32  NumberOfElements = 1 }            
            }
	    }
		+GAMSimulink1 = {
 			Class = SimulinkWrapperGAM
			Library = "/root/cfsalgo1.so"			
			SymbolPrefix = "cfsalgo1"			
			Verbosity = 2
			SkipInvalidTunableParams = 0
            TunableParamExternalSource= "MDSParamLoader1"
			InputSignals = {		
				input	= { DataSource = DDB1 Type = uint32 NumberOfElements = 1 NumberOfDimensions=0 Alias = Counter }
 			}
 			OutputSignals = { 
				outputs1	= { DataSource = DDB1 Type = float32 NumberOfElements = 1 NumberOfDimensions=0 }		
				outputs2	= { DataSource = DDB1 Type = float32 NumberOfElements = 1 NumberOfDimensions=0 }		
				outputv1	= { DataSource = DDB1 Type = float32 NumberOfElements = 1 NumberOfDimensions=0 }		
				outputv2	= { DataSource = DDB1 Type = float32 NumberOfElements = 1 NumberOfDimensions=0 }		
				outputm1	= { DataSource = DDB1 Type = float32 NumberOfElements = 1 NumberOfDimensions=0 }		
				outputm2	= { DataSource = DDB1 Type = float32 NumberOfElements = 1 NumberOfDimensions=0 }		
            }
			Parameters    =  {
                //k2 = (float32) 2.5
                //vectorParameter = (uint32)  { 0, 1, 2, 3 }
                //matrixParameter = (float64) { {0.0, 1.0}, {2.0, 3.0} }
                //ks1 = (float32) 1.0;
                ks2 = (float32) 1.0
                //kv1 = (float32) { 1.0, 1.0 }
                kv2 = (float32) { 1.0, 1.0 }
                //km1 = (float32) {{ 1.0, 1.0 }, { 1.0, 1.0 }}
                km2 = (float32) {{ 1.0, 1.0 }, { 1.0, 1.0 }}                
            }
		}
		+StorageBroker = {
		 Class = IOGAM
		 InputSignals = {
            outputs1                    = { DataSource = DDB1 Type = float32 }
            Thread1_CycleTime           = { DataSource = Timings Type = uint32 Alias = State1.Thread1_CycleTime }
            GAMSimulink1_ReadTime  		= { DataSource = Timings Type = uint32 } 
	        GAMSimulink1_ExecTime  		= { DataSource = Timings Type = uint32 }  
	        GAMSimulink1_WriteTime 		= { DataSource = Timings Type = uint32 } 
		 }
		 OutputSignals = {
            outputs1                    = { DataSource = MDSWriter_0 Type = float32 }
            Thread1_Cycletime           = { DataSource = MDSWriter_0 Type = uint32 }
            GAMSimulink1_ReadTime  		= { DataSource = MDSWriter_0 Type = uint32 } 
	        GAMSimulink1_ExecTime  		= { DataSource = MDSWriter_0 Type = uint32 }  
	        GAMSimulink1_WriteTime 		= { DataSource = MDSWriter_0 Type = uint32 } 
		 }
		}
        +LoggerBroker = {
		 Class = IOGAM
		 InputSignals = {
		 	Counter = { DataSource = DDB1 Type = uint32  }
    	  	outputs1  = { DataSource = DDB1 Type = float32 }
    	  	outputs2  = { DataSource = DDB1 Type = float32 }
    	  	outputv1  = { DataSource = DDB1 Type = float32 }
    	  	outputv2  = { DataSource = DDB1 Type = float32 }
    	  	outputm1  = { DataSource = DDB1 Type = float32 }
    	  	outputm2  = { DataSource = DDB1 Type = float32 }
            mdsint1   = { DataSource = DDB1 Type = uint32  }
            mdsintime = { DataSource = DDB1 Type = int32   } 

        }
		 OutputSignals = {
		 	Counter = { DataSource = LoggerDataSource Type = uint32  }
            outputs1  = { DataSource = LoggerDataSource Type = float32 }
            outputs2  = { DataSource = LoggerDataSource Type = float32 }
            outputv1  = { DataSource = LoggerDataSource Type = float32 }
            outputv2  = { DataSource = LoggerDataSource Type = float32 }
            outputm1  = { DataSource = LoggerDataSource Type = float32 }
            outputm2  = { DataSource = LoggerDataSource Type = float32 }            
            mdsint1   = { DataSource = LoggerDataSource Type = uint32  }
            mdsintime = { DataSource = LoggerDataSource Type = int32   } 
         }
        } 
    }
    +Data = {
        Class = ReferenceContainer
        DefaultDataSource = DDB1
        +DDB1 = { Class = GAMDataSource }    
        +LoggerDataSource = { Class = LoggerDataSource }
        +Timings = { Class = TimingDataSource }
        +Timer = {
            Class = LinuxTimer
            SleepNature = "Default"
            Signals = {
                Counter = { Type = uint32 }
                Time = { Type = uint32 }
            }
        }
        +MDSReader_0 = {
            Class = MDSReader
            TreeName = "martetest" //Compulsory. Name of the MDSplus tree.
            ShotNumber = 10 //Compulsory. 0 --> last shot number (to use 0 shotid.sys must exist)
            Frequency = 1 // in Hz. Is the cycle time of the real time application.
            Signals = {
                mdsint1 = {
                    NodeName = "AI.CH003" // node of the tree node
                    Type = "uint32" //Can be any of the node supported types
                    NumberOfElements = 1
                    DataManagement = 0 //could be 0, 1 or 2
                    HoleManagement = 1 //could be 0 or 1
                }
                Time = { //Compulsory
                    Type = "int32" //can be any of the supported types
                    NumberOfElements = 1 //must be always one.
                }
            }       
        }
        +MDSWriter_0 = {
            Class = MDSWriter
            NumberOfBuffers = 2000 //Compulsory. Number of buffers in the circular buffer defined above. Each buffer is capable of holding a copy of all the DataSourceI signals.
            CPUMask = 0x8 //Compulsory. Affinity assigned to the threads responsible for asynchronously flush data into the MDSplus database.
            StackSize = 10000000 //Compulsory. Stack size of the thread above.
            TreeName = "martetest" //Compulsory. Name of the MDSplus tree.
            PulseNumber = 10 //Optional. If -1 a new pulse will be created and the MDSplus pulse number incremented.
            StoreOnTrigger = 0 //Compulsory. If 0 all the data in the circular buffer is continuously stored. If 1 data is stored when the Trigger signal is 1 (see below).
            EventName = "updatejScope" //Compulsory. Event sent to jScope when TimeRefresh seconds have elapsed.
            TimeRefresh = 5 //Compulsory. An event with the name set in the property EventName is sent to jScope when TimeRefresh seconds have elapsed.
            NumberOfPreTriggers = 0 //Compulsory iff StoreOnTrigger = 1.  Number of cycles to store before the trigger.
            NumberOfPostTriggers = 0 //Compulsory iff StoreOnTrigger = 1.  Number of cycles to store after the trigger.
            Signals = {
            /*
                Trigger = { //Compulsory when StoreOnTrigger = 1. Must be set in index 0 of the Signals node. When the value of this signal is 1 data will be stored.
                    Type = uint8 //Type must be uint8
                }
                Time = { //Compulsory when StoreOnTrigger = 1. Can be store in any index, but TimeSignal must be set = 1
                    Type = uint32 //Type must be uint32 or int32
                    TimeSignal = 1 //When set, this signal will be considered as the time source against which all signals will be stored.
                    TimeSignalMultiplier = 1e-9 //Default = 1e-6. Multiplier to convert the time signal units into seconds,
                }
            */
            
                Thread1_Cycletime       = { NodeName = "ST.CH01" Period = 1 AutomaticSegmentation = 0 MakeSegmentAfterNWrites = 2000 SamplePhase = 0 }
                GAMSimulink1_ReadTime   = { NodeName = "ST.CH02" Period = 1 AutomaticSegmentation = 0 MakeSegmentAfterNWrites = 2000 SamplePhase = 0 }
                GAMSimulink1_ExecTime   = { NodeName = "ST.CH03" Period = 1 AutomaticSegmentation = 0 MakeSegmentAfterNWrites = 2000 SamplePhase = 0 }
                GAMSimulink1_WriteTime  = { NodeName = "ST.CH04" Period = 1 AutomaticSegmentation = 0 MakeSegmentAfterNWrites = 2000 SamplePhase = 0 }
            
                outputs1 = { //As many as required.
                    NodeName = "AO.CH01" //Compulsory. MDSplus node name
                    Period = 1 //Compulsory. Period between signal samples.
                    AutomaticSegmentation = 0 // 1 || 0. When set to 1 MDSplus::putRow() is used instead of MDSplus::makeSegment()
                    MakeSegmentAfterNWrites = 2000 //Compulsory if AutomaticSegmentation = 0. Forces the creation of a segment after N MARTe cycles. If AutomaticSegmentation = 0 then MakeSegmentAfterNWrites = 1.
                    /*
                    DecimatedNodeName = "SIGUINT16D" //Optional. The node where MDSplus stores the automatically computed decimated signal. When AutomaticSegmentation = 1 this field is ignored.
                    MinMaxResampleFactor = 4 //Compulsory if DecimatedNodeName is set. Decimation factor that MDSplus applies to the decimated version of the signal. AutomaticSegmentation = 1 this field is ignored.
                    */
                    SamplePhase = 0 //Optional. Shift the time vector by SamplePhase * Period
                    //DiscontinuityFactor = 0.    // Optional. A discontinuity is considered if the delta between two consecutive samples is greater than T+DiscontinuityFactor*T (where T is the nominal period) or
                                                // minor than max(T-DiscontinuityFactor*T, 0). If a discontinuity is detected, the samples will be flushed and a new segment created for the next ones.
                }

            }
            /*
            +Messages = { //Optional. If set a message will be fired every time one of the events below occur
                Class = ReferenceContainer
                +TreeOpenedOK = { //Optional, but if set, the name of the Object shall be TreeOpenedOK. If set a message containing a ConfigurationDatabase with param1=PULSE_NUMBER will be sent to the Destination, every time the Tree is successfully opened
                    Class = Message
                    Destination = SomeObject
                    Function = SomeFunction
                    Mode = ExpectsReply
                }
                +TreeOpenedFail = { //Optional, but if set, the name of the Object shall be TreeOpenedFail. If set a message will be sent to the Destination, every time the Tree cannot be successfully opened
                    Class = Message
                    Destination = SomeObject
                    Function = SomeFunction
                    Mode = ExpectsReply
                }
                +TreeFlushed = { //Optional, but if set, the name of the Object shall be TreeFlushed. If set a message will be sent to the Destination, every time the Tree is flushed.
                    Class = Message
                    Destination = SomeObject
                    Function = SomeFunction
                    Mode = ExpectsReply
                }
            }
            */
        }
    }
    +States = {
        Class = ReferenceContainer
        +State1 = {
            Class = RealTimeState
            +Threads = {
                Class = ReferenceContainer
                +Thread1 = {
                    Class = RealTimeThread 
                    CPUs = 0x4
                    Functions = {
                      GAMTimer                         	      
                      Constants
                      ReaderBroker
                      GAMSimulink1
                      StorageBroker
                      //LoggerBroker
                    }
                }
            }
        }        
    }
    +Scheduler = {
        Class = GAMScheduler
        TimingDataSource = Timings
    }
}



/**
 * @brief MDSReader is a data source which allows to read data from a MDSplus tree.
 * @details MDSReader is an input data source which takes data from MDSPlus nodes (as many as desired) and publishes it on a real time application.
 *
 * The MDSReader can either interpolate, decimate or take the raw data, as it is, from the tree depending on the parameter called "DataManagement" which is given
 * in the configuration file.
 * Moreover, this data source can deal with discontinuous data and has a configuration parameter for managing the absence of data.
 * DataManagement can take the following values:
 * <ul>
 * <li>0 --> MDSReader takes the data from the tree as it is (raw). In this configuration, the frequency/numberOfElements must be the same than the node sampling frequency.</li>
 * <li>1--> MDSReader interpolates the signal taking as a reference the two nearest data values. If the frequency/numberOfElements is smaller than the sample frequency
 * of the MDSplus node the data source interpolates the signal. If the frequency/numberOfElements larger than the node sample frequency the signals is decimated.</li>
 * <li>2 --> MDSReader holds the value following the criteria of the nearest value given specific time. I.e the node data is (t1, d1) = (1, 1) and (t2, d2) = (2, 5) and the currentTime is t = 1.6 the
 * nearest data to the given time is 5.</li>
 * </ul>
 *
 * HoleManagement can take the following values:
 * <ul>
 * <li>0 --> MDSreader fills the absence of data with 0</li>
 * <li>1 --> MDSReader fills the absence of data with the last value.</li>
 * </ul>
 *
 * Even if the MDSReader can deal with the absence of data, the sampling time must be constant with-in the node, however the sampling time between
 * nodes can be different.
 *
 * The MDSReader can handle as many nodes as desired. Each node can have their on data type, maximum number of segments, elements per segment and sampling time. When the
 * end of a node is reached the data of the corresponding node is filled with 0 and the data source continuous running until all nodes reach the end.
 *
 * The supported types for the nodes are:
 * <ul>
 * <li>uint8</li>
 * <li>int8</li>
 * <li>uint16</li>
 * <li>int16</li>
 * <li>uint32</li>
 * <li>int32</li>
 * <li>uint64</li>
 * <li>int64</li>
 * <li>float32</li>
 * <li>float64</li>
 * </ul>
 *
 * The last signal specified must be the time.
 * The supported type for the time are:
 * <ul>
 * <li>uint32</li>
 * <li>int32</li>
 * <li>uint64</li>
 * <li>int64</li>
 * </ul>
 */
