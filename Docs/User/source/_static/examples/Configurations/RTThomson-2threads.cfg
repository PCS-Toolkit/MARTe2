/*
 TCV SCD MARTe2 cfg file
 real-time Thomson scattering acquisition system FAT tester
 TCV
 CGalperti 17.07.20

 - ADC setup script inserted into ShotManager (InitScript), 
 - ADC abort (transient stop) inserted as exiyt and abort script into ShotManager
 - 1 thread, AFHBA404 timing, transient auto termination on #samples based or manual termination on RUNCOMPLETE message to state machine
 - ADC control scripts ENABLED
 - state machine
 - TCP server for advancing state machine, ShotManager for sending status to MDS+  and calling necessary D-TACQ HAPI scripts
 - MDS+ storage of algorithm outputs and timings
 
 CPUs allocation (i9thomsonlayout):
 1 0x01 System (not isolated)
 2 0X02 System (not isolated)
 3 0x04 MDSWriter1, MDSWriter2
 4 0x08 ADC polling + RT Thread 1
 5 0x10 RT thomson computation thread
 6
 7
 8
 9
 10
 
 Changelog:
 
 - 17.07.20 CG first written from tcvrt03-1005-FPS
*/

+ShotManager = {
 Class = SPCShotManager
 Server = spcpc171.epfl.ch
 Tree = martetest
 Shot = 1
 Statusnode = ST.CH20
 InitScript = "/root/scd/commands/llc-run-thomson-setup" // script called upon entering init (for TS sets up SOD ADC systems, 
 ExitScript = "/root/scd/commands/llc-run-thomson-abort" // script called upon exiting (for TS aborts the transient acquisition on ADCs, llc-run-thomson-abort, same also for AbortScript in this case)
 AbortScript = "/root/scd/commands/llc-run-thomson-abort" 

// The parameter param1 is the shotnumber to be opened 
 //+OpenTreeMsg1 = { Class = Message Destination = RTApp.Data.MDSWriter1 Function = OpenTree Mode = ExpectsReply +Parameters = { Class = ConfigurationDatabase param1 = 0 } } 
 //+OpenTreeMsg2 = { Class = Message Destination = RTApp.Data.MDSWriter2 Function = OpenTree Mode = ExpectsReply +Parameters = { Class = ConfigurationDatabase param1 = 0 } }
}

+TCPMessageProxy = {
    Class = TCPSocketMessageProxyExample
    Port = 24680
}

+StateMachine = {
 Class = StateMachine
 +INITIAL = {
  Class = ReferenceContainer
  +RUN = {
   Class = StateMachineEvent
   NextState = "RUN"
   NextStateError = "ERROR"
   Timeout = 0
   +ChangeToRunMsg               = { Class = Message Destination = RTApp     Function = PrepareNextState Mode = ExpectsReply +Parameters = { Class = ConfigurationDatabase param1 = Run } }
   +StartNextStateExecutionMsg   = { Class = Message Destination = RTApp     Function = StartNextStateExecution Mode = ExpectsReply }
   +ShotManagerStartMsg 	     = { Class = Message Destination = ShotManager Function = Run Mode = ExpectsReply }
  }
  +ERROR = {
   Class = StateMachineEvent
   NextState = "ERROR"
   NextStateError = "ERROR"
   Timeout = 0
   +ShotManagerErrorMsg 	     = { Class = Message Destination = ShotManager Function = Error Mode = ExpectsReply }  
  }
  +EXIT = {
   Class = StateMachineEvent
   NextState = "FINAL"
   NextStateError = "ERROR"
   Timeout = 0
   +ExitAppMsg = { Class = Message Destination = ShotManager     Function = Exit }   
  }
  +ABORT = {
   Class = StateMachineEvent
   NextState = "FINAL"
   NextStateError = "ERROR"
   Timeout = 0
   +ExitAppMsg = { Class = Message Destination = ShotManager     Function = Exit }   
  }
 }
 +RUN = {
  Class = ReferenceContainer
  +RUNCOMPLETE = {
   Class = StateMachineEvent
   NextState = "ENDRUN"
   NextStateError = "ERROR"
   Timeout = 0
   // We stop LLC because RUNCOMPLETE could come before shot termination (# samples not known a priori in Thomson case)
   +StopLLCMsg					   = { Class = Message Destination = RTApp.Data.ADCSystem  Function = StopLLC Mode = ExpectsReply }
   +StopCurrentStateExecutionMsg = { Class = Message Destination = RTApp     			Function = StopCurrentStateExecution Mode = ExpectsReply }
   +MdsFlushSegmentsMsg1         = { Class = Message Destination = RTApp.Data.MDSWriter1 Function = FlushSegments Mode = ExpectsReply }
   +MdsFlushSegmentsMsg2         = { Class = Message Destination = RTApp.Data.MDSWriter2 Function = FlushSegments Mode = ExpectsReply }
   +ShotManagerStopMsg 			 = { Class = Message Destination = ShotManager 			Function = Stop Mode = ExpectsReply }
  }
  +ABORT = {
   Class = StateMachineEvent
   NextState = "FINAL"
   NextStateError = "ERROR"
   Timeout = 0
   +StopLLCMsg					   = { Class = Message Destination = RTApp.Data.ADCSystem  Function = StopLLC Mode = ExpectsReply }
   +StopCurrentStateExecutionMsg = { Class = Message Destination = RTApp     			Function = StopCurrentStateExecution Mode = ExpectsReply }
   +ShotManagerAbortMsg 		 = { Class = Message Destination = ShotManager 			Function = Abort Mode = ExpectsReply }
  }
 }
 +ENDRUN = {
  Class = ReferenceContainer
  +ENTER = {
   Class = ReferenceContainer
   //+StopCurrentStateExecutionMsg = { Class = Message Destination = RTApp     Function = StopCurrentStateExecution Mode = ExpectsReply }   
   //+ShotManagerStopMsg 			 = { Class = Message Destination = ShotManager Function = Stop Mode = ExpectsReply }
  }
  +EXIT = {
   Class = StateMachineEvent
   NextState = "FINAL"
   NextStateError = "ERROR"
   Timeout = 0
   +ExitAppMsg = { Class = Message Destination = ShotManager     Function = Exit }   
  }
  +ABORT = {
   Class = StateMachineEvent
   NextState = "FINAL"
   NextStateError = "ERROR"
   Timeout = 0
   +ExitAppMsg = { Class = Message Destination = ShotManager     Function = Exit }   
  }
 } 
 +FINAL = {
  Class = ReferenceContainer
  +FINAL = {
   Class = StateMachineEvent
   NextState = "FINAL"
   NextStateError = "ERROR"
   Timeout = 0   
  } 
 }
 +ERROR = {
  Class = ReferenceContainer  
  +ENTER = {
   Class = ReferenceContainer
   +ShotManagerErrorMsg = { Class = Message Destination = ShotManager     Function = Error Mode = ExpectsReply }   
  }  
  +EXIT = {
   Class = StateMachineEvent
   NextState = "FINAL"
   NextStateError = "ERROR"
   Timeout = 0
   +ExitAppMsg = { Class = Message Destination = ShotManager     Function = Exit }   
  }
 }
}

+MDSParameters = {
 Class=MDSObjLoader
 Shot=-1
}

$RTApp = {
    Class = RealTimeApplication
    +Functions = {
        Class = ReferenceContainer
         
        /********************************************************/
        /* THREAD1                                              */
        /********************************************************/                    
        +ADCBroker = {
            Class = IOGAM
            InputSignals = {
                Counter      = {                   DataSource = ADCSystem Type = int32 NumberOfElements = 4 }                
                Time         = { 				   DataSource = ADCSystem Type = int32 Frequency = 1000 }
            	ADCuscounter = {                   DataSource = ADCSystem Type = uint32 NumberOfElements = 4 }
                ADCinputs    = {                   DataSource = ADCSystem Type = int16 NumberOfElements = 768 NumberOfDimensions = 1 }
            }
            OutputSignals = {
                Counter      = {                   DataSource = DDB1  Type = int32 NumberOfElements = 4 }                
                Time         = {                   DataSource = DDB1  Type = int32 Default = 0 }      
                ADCuscounter = {                   DataSource = DDB1  Type = uint32 NumberOfElements = 4 }
                realadc      = {                   DataSource = DDB1  Type = int16 NumberOfElements = 768 NumberOfDimensions = 1 }   
            }
        }       
        +TimeSignals = {
        	Class = SPCTimeGAM
        	MdsTimeOffset = 0       
			MdsStartTime = 0 
			MdsStopTime = 10000000   			
        	InputSignals = {
        		Time  = { DataSource = DDB1     Type = int32 }
        	}
        	OutputSignals = {
        		realtime         = { DataSource = DDB1 Type = float32     }
				offsettimeforMDS = { DataSource = DDB1 Type = int32       }
				triggerforMDS    = { DataSource = DDB1 Type = uint8       }
        	}
        }     
        +TimingSignalsBroker1 = {
         Class = IOGAM
         InputSignals = { 
         	Thread1_CycleTime    			= { DataSource = Timings Type = uint32 Alias = Run.Thread1_CycleTime }
	        ADCBroker_ReadTime    			= { DataSource = Timings Type = uint32 Default = 0 } 	        
	        ADCBroker_ExecTime    			= { DataSource = Timings Type = uint32 Default = 0 } 
	        ADCBroker_WriteTime    			= { DataSource = Timings Type = uint32 Default = 0 }    
	        StorageBroker1_ReadTime        	= { DataSource = Timings Type = uint32 Default = 0 } 	       
	        StorageBroker1_ExecTime        	= { DataSource = Timings Type = uint32 Default = 0 } 
	        StorageBroker1_WriteTime       	= { DataSource = Timings Type = uint32 Default = 0 } 
         }
         OutputSignals = { 
         	Thread1_CycleTime    			= { DataSource = DDB1 Type = uint32 Default = 0 }     
	        ADCBroker_Time    				= { DataSource = DDB1 Type = uint32 NumberOfElements = 3 } 	        
	        StorageBroker1_Time        		= { DataSource = DDB1 Type = uint32 NumberOfElements = 3 }
         }                                                  
        }                                                   
        +T1TSynch = {
            Class = IOGAM
            InputSignals = {
                Counter      = {                   DataSource = DDB1  Type = int32 NumberOfElements = 4 }                
                realtime     = {                   DataSource = DDB1  Type = float32 Default = 0 }      
                ADCuscounter = {                   DataSource = DDB1  Type = uint32 NumberOfElements = 4 }
                realadc      = {                   DataSource = DDB1  Type = int16 NumberOfElements = 768 NumberOfDimensions = 1 }   
            }
            OutputSignals = {
                Counter      = {                   DataSource = RTThreadSynch1  Type = int32 NumberOfElements = 4 }                
                realtime     = {                   DataSource = RTThreadSynch1  Type = float32 Default = 0 }      
                ADCuscounter = {                   DataSource = RTThreadSynch1  Type = uint32 NumberOfElements = 4 }
                realadc      = {                   DataSource = RTThreadSynch1  Type = int16 NumberOfElements = 768 NumberOfDimensions = 1 }   
            }
        } 
	
        /********************************************************/
        /* THREAD2                                              */
        /********************************************************/                    
        +T1T2Com = {
            Class = IOGAM
            InputSignals = {
                Counter      = {                   DataSource = RTThreadSynch1  Type = int32 NumberOfElements = 4 Samples = 1 }                
                realtime     = {                   DataSource = RTThreadSynch1  Type = float32 Default = 0 Samples = 1}      
                ADCuscounter = {                   DataSource = RTThreadSynch1  Type = uint32 NumberOfElements = 4 Samples = 1 }
                realadc      = {                   DataSource = RTThreadSynch1  Type = int16 NumberOfElements = 768 NumberOfDimensions = 1 Samples = 1 }   
            }
            OutputSignals = {
                Counter      = {                   DataSource = DDB2  Type = int32 NumberOfElements = 4 Samples = 1 }                
                realtime     = {                   DataSource = DDB2  Type = float32 Default = 0 Samples = 1 }      
                ADCuscounter = {                   DataSource = DDB2  Type = uint32 NumberOfElements = 4 Samples = 1 }
                realadc      = {                   DataSource = DDB2  Type = int16 NumberOfElements = 768 NumberOfDimensions = 1 Samples = 1 }               
            }      
        }	
        +Constants = {
            Class = ConstantGAM
            OutputSignals = {
				it_dummy 	= { DataSource = DDB2 Type = int32  NumberOfElements = 1   NumberOfDimensions=1 }
				time_dummy 	= { DataSource = DDB2 Type = float32  NumberOfElements = 1   NumberOfDimensions=1 }
				data_dummy	= { DataSource = DDB2 Type = int16  NumberOfElements = 528   NumberOfDimensions=1 }				
				testep_d	= { DataSource = DDB2 Type = float32  NumberOfElements = 109   NumberOfDimensions=1 }		
				testeperr_d	= { DataSource = DDB2 Type = float32  NumberOfElements = 109   NumberOfDimensions=1 }		
				nestep_d	= { DataSource = DDB2 Type = float32  NumberOfElements = 109   NumberOfDimensions=1 }		
				nesteperr_d	= { DataSource = DDB2 Type = float32  NumberOfElements = 109   NumberOfDimensions=1 }		
            }
        }
        +SpectroRouter = {
            Class = IOGAM
            InputSignals = {
                


               	data_dummy_1	                    = { DataSource = DDB2 Type = int16 NumberOfElements = 528 NumberOfDimensions = 1 Ranges ={{0,281}} Alias = data_dummy }	

		// input 283 is LASER power monitor	

		adc1      					    = { DataSource = DDB2 Type = int16 NumberOfElements = 768 NumberOfDimensions = 1 Ranges ={{0,0}}     Alias = realadc }   
                

               	data_dummy_2	                    = { DataSource = DDB2 Type = int16 NumberOfElements = 528 NumberOfDimensions = 1 Ranges ={{0,174}} Alias = data_dummy }	

		// spectro 152 at 459..462

                adc577      					= { DataSource = DDB2 Type = int16 NumberOfElements = 768 NumberOfDimensions = 1 Ranges ={{576,576}} Alias = realadc }   
                adc385      					= { DataSource = DDB2 Type = int16 NumberOfElements = 768 NumberOfDimensions = 1 Ranges ={{384,384}} Alias = realadc }   
		adc193      					= { DataSource = DDB2 Type = int16 NumberOfElements = 768 NumberOfDimensions = 1 Ranges ={{192,192}} Alias = realadc }   
                adc2							= { DataSource = DDB2 Type = int16 NumberOfElements = 768 NumberOfDimensions = 1 Ranges ={{1,1}}     Alias = realadc }   
                
		data_dummy_3	                    = { DataSource = DDB2 Type = int16 NumberOfElements = 528 NumberOfDimensions = 1 Ranges ={{0,65}} Alias = data_dummy }	

		// 1 st DTACQ sample counter

		Counter		    = { DataSource = DDB2 Type = int32  	NumberOfElements = 4 Ranges={{0,0}} NumberOfDimensions=1}
            }
            OutputSignals = {
                routedadc      = {                   DataSource = DDB2  Type = int16 NumberOfElements = 528 NumberOfDimensions = 1 }
                counter1      = {                   DataSource = DDB2  Type = int32 NumberOfElements = 1 NumberOfDimensions = 1 }
            }
        }
        +GAMSimulink2 = {
 			Class = SimulinkWrapperGAM
			Library = "/root/TS_RT_step.so"
			SymbolPrefix = "TS_RT_step"

			Verbosity = 2
			TunParSourceGAM = MDSParameters
			SkipNotOkTunParams = 1
			InputSignals = {		
				it		    = { DataSource = DDB2 Type = int32  	NumberOfElements = 1 NumberOfDimensions=1 Alias = counter1 }
				time		= { DataSource = DDB2 Type = float32    NumberOfElements = 1                NumberOfDimensions=1 Alias = realtime }
				data		= { DataSource = DDB2 Type = int16  	NumberOfElements = 528              NumberOfDimensions=1 Alias = routedadc }				
 			}
 			OutputSignals = { 
				testep	= { DataSource = DDB2 Type = float32  NumberOfElements = 109   NumberOfDimensions=1 }		
				testeperr	= { DataSource = DDB2 Type = float32  NumberOfElements = 109   NumberOfDimensions=1 }		
				nestep	= { DataSource = DDB2 Type = float32  NumberOfElements = 109   NumberOfDimensions=1 }		
				nesteperr	= { DataSource = DDB2 Type = float32  NumberOfElements = 109   NumberOfDimensions=1 }				
 			}
			//+SimulinkReadyMsg = { Class = Message Destination = RTApp.Data.MDSWriter1 Function = SetupBusSignals Mode = ExpectsReply +Parameters = { Class = ConfigurationDatabase param1 = RTApp.Functions.GAMSimulink1 } }			
	}
	+TimingSignalsBroker2 = {
         Class = IOGAM
         InputSignals = { 
         	Thread2_CycleTime    			= { DataSource = Timings Type = uint32 Alias = Run.Thread2_CycleTime }
	        GAMSimulink2_ReadTime    		= { DataSource = Timings Type = uint32 Default = 0 } 	        
	        GAMSimulink2_ExecTime    		= { DataSource = Timings Type = uint32 Default = 0 } 
	        GAMSimulink2_WriteTime    		= { DataSource = Timings Type = uint32 Default = 0 }    
	        StorageBroker2_ReadTime        	= { DataSource = Timings Type = uint32 Default = 0 } 	       
	        StorageBroker2_ExecTime        	= { DataSource = Timings Type = uint32 Default = 0 } 
	        StorageBroker2_WriteTime       	= { DataSource = Timings Type = uint32 Default = 0 } 
         }
         OutputSignals = { 
         	Thread2_CycleTime    			= { DataSource = DDB2 Type = uint32 Default = 0 }     
	        GAMSimulink2_Time    			= { DataSource = DDB2 Type = uint32 NumberOfElements = 3 } 	        
	        StorageBroker2_Time        		= { DataSource = DDB2 Type = uint32 NumberOfElements = 3 }
         }                                                  
        }                                                   
	
        /********************************************************/
        /* MDS STORAGE THREADS                                   */
        /********************************************************/      			
	+StorageBroker1 = {
		 Class = IOGAM
		 InputSignals = {	           	
            Counter      					= { DataSource = DDB1 Type = int32 NumberOfElements = 4 }                
            Time         					= { DataSource = DDB1 Type = int32 Default = 0 }      
            ADCuscounter 					= { DataSource = DDB1 Type = uint32 NumberOfElements = 4 }
            adc1      					    = { DataSource = DDB1 Type = int16 NumberOfElements = 768 NumberOfDimensions = 1 Ranges ={{0,0}}     Alias = realadc }   
			adc2							= { DataSource = DDB1 Type = int16 NumberOfElements = 768 NumberOfDimensions = 1 Ranges ={{1,1}}     Alias = realadc }   
            adc193      					= { DataSource = DDB1 Type = int16 NumberOfElements = 768 NumberOfDimensions = 1 Ranges ={{192,192}} Alias = realadc }   
            adc385      					= { DataSource = DDB1 Type = int16 NumberOfElements = 768 NumberOfDimensions = 1 Ranges ={{384,384}} Alias = realadc }   
            adc577      					= { DataSource = DDB1 Type = int16 NumberOfElements = 768 NumberOfDimensions = 1 Ranges ={{576,576}} Alias = realadc }   
         
         	Thread1_CycleTime    			= { DataSource = DDB1 Type = uint32 }
	        ADCBroker_Time    				= { DataSource = DDB1 Type = uint32 NumberOfElements = 3 } 	        	       	        
	        StorageBroker1_Time        		= { DataSource = DDB1 Type = uint32 NumberOfElements = 3 } 	       
		 }
		 OutputSignals = {
            Counter      					= { DataSource = MDSWriter1 Type = int32 NumberOfElements = 4 }                
            Time         					= { DataSource = MDSWriter1 Type = int32 Default = 0 }      
            ADCuscounter 					= { DataSource = MDSWriter1 Type = uint32 NumberOfElements = 4 }
            adc1      					    = { DataSource = MDSWriter1 Type = int16 NumberOfElements = 1 NumberOfDimensions = 1 }   
            adc2      					    = { DataSource = MDSWriter1 Type = int16 NumberOfElements = 1 NumberOfDimensions = 1 }               
            adc193      					= { DataSource = MDSWriter1 Type = int16 NumberOfElements = 1 NumberOfDimensions = 1 }   
            adc385      					= { DataSource = MDSWriter1 Type = int16 NumberOfElements = 1 NumberOfDimensions = 1 }   
            adc577      					= { DataSource = MDSWriter1 Type = int16 NumberOfElements = 1 NumberOfDimensions = 1 }   

          	Thread1_CycleTime    			= { DataSource = MDSWriter1 Type = uint32 Default = 0 }
	      	ADCBroker_Time    				= { DataSource = MDSWriter1 Type = uint32 NumberOfElements = 3 } 	        	       	        
	      	StorageBroker1_Time        		= { DataSource = MDSWriter1 Type = uint32 NumberOfElements = 3 }        
		 }
		}
	+StorageBroker2 = {
		 Class = IOGAM
		 InputSignals = {	           	
            Counter      					= { DataSource = DDB2 Type = int32 NumberOfElements = 4 }                
            realtime         			    = { DataSource = DDB2 Type = float32 Default = 0 }      
         
            testep	                        = { DataSource = DDB2 Type = float32  NumberOfElements = 109   NumberOfDimensions=1 }		
            //testep	                        = { DataSource = DDB2 Type = float32  NumberOfElements = 109   NumberOfDimensions=1 Alias = testep_d }		
            testeperr	                    = { DataSource = DDB2 Type = float32  NumberOfElements = 109   NumberOfDimensions=1 }		
            //testeperr	                    = { DataSource = DDB2 Type = float32  NumberOfElements = 109   NumberOfDimensions=1 Alias = testeperr_d }		
            nestep	                        = { DataSource = DDB2 Type = float32  NumberOfElements = 109   NumberOfDimensions=1 }		
            //nestep	                        = { DataSource = DDB2 Type = float32  NumberOfElements = 109   NumberOfDimensions=1 Alias = nestep_d }		
            nesteperr	                    = { DataSource = DDB2 Type = float32  NumberOfElements = 109   NumberOfDimensions=1 }				
            //nesteperr	                    = { DataSource = DDB2 Type = float32  NumberOfElements = 109   NumberOfDimensions=1 Alias = nesteperr_d }				
         
         	Thread2_CycleTime    			= { DataSource = DDB2 Type = uint32 Default = 0 }     
	        GAMSimulink2_Time    			= { DataSource = DDB2 Type = uint32 NumberOfElements = 3 } 	        
	        StorageBroker2_Time        		= { DataSource = DDB2 Type = uint32 NumberOfElements = 3 }
		 }
		 OutputSignals = {
            Counter      					= { DataSource = MDSWriter2 Type = int32 NumberOfElements = 4 }                
            realtime         				= { DataSource = MDSWriter2 Type = float32 Default = 0 }      

            testep	                        = { DataSource = MDSWriter2 Type = float32  NumberOfElements = 109   NumberOfDimensions=1 }		
            testeperr	                    = { DataSource = MDSWriter2 Type = float32  NumberOfElements = 109   NumberOfDimensions=1 }		
            nestep	                        = { DataSource = MDSWriter2 Type = float32  NumberOfElements = 109   NumberOfDimensions=1 }		
            nesteperr	                    = { DataSource = MDSWriter2 Type = float32  NumberOfElements = 109   NumberOfDimensions=1 }				            
            
            Thread2_CycleTime    			= { DataSource = MDSWriter2 Type = uint32 Default = 0 }     
	        GAMSimulink2_Time    			= { DataSource = MDSWriter2 Type = uint32 NumberOfElements = 3 } 	        
	        StorageBroker2_Time        		= { DataSource = MDSWriter2 Type = uint32 NumberOfElements = 3 }
		 }
		}
		
		+LoggerBroker = {
		 Class = IOGAM
		 InputSignals = {
                //Counter      = {                   DataSource = DDB1  Type = int32 NumberOfElements = 4 }                
                //Time         = {                   DataSource = DDB1  Type = int32 }      
                //ADCuscounter = {                   DataSource = DDB1  Type = uint32 NumberOfElements = 4 }
                //realadc      = {                   DataSource = DDB1  Type = int16 NumberOfElements = 768 NumberOfDimensions = 1 Ranges = {{0,0}} }   
                realtime      = {                   DataSource = DDB2  Type = float32 NumberOfElements = 1 NumberOfDimensions = 1 }   
                //realtime      = {                   DataSource = DDB1  Type = float32 NumberOfElements = 1 NumberOfDimensions = 1 }   
		 }
		 OutputSignals =
		 {
		    //Counter 	 = 	{ DataSource = LoggerDataSource Type = int32 NumberOfElements = 4 }
		    //Time    	 = 	{ DataSource = LoggerDataSource Type = int32 }
            //ADCuscounter =  { DataSource = LoggerDataSource Type = uint32 NumberOfElements = 4 }
            //adc1      =  { DataSource = LoggerDataSource Type = int16 NumberOfElements = 1  }   
           realtime      =  { DataSource = LoggerDataSource Type = float32 NumberOfElements = 1  }   
		 }
		} 
		
    }
    +Data = {
        Class = ReferenceContainer
        DefaultDataSource = DDB1        
        +DDB1 				= { Class = GAMDataSource }
        +DDB2 				= { Class = GAMDataSource }
        +LoggerDataSource 	= { Class = LoggerDataSource }  
        +Timings 			= { Class = TimingDataSource }       
                 
        +ADCSystem = {
 	    	Class = AFHBA404::ACQ2106TSIN
			// TODO: IndependentThread isn't working, thread semaphore not handled by Execute, to be fixed
			ExecutionMode = RealTimeThread //Optional. If not set ExecutionMode = IndependentThread. If ExecutionMode == IndependentThread a thread is spawned to generate the time events. ExecutionMode == RealTimeThread the time is generated in the context of the real-time thread.
		    //ExecutionMode = IndependentThread //Optional. If not set ExecutionMode = IndependentThread. If ExecutionMode == IndependentThread a thread is spawned to generate the time events. ExecutionMode == RealTimeThread the time is generated in the context of the real-time thread.			
			CPUMask = 0x08 //Optional and only relevant if ExecutionMode=IndependentThread
     		Cycles = 1000
     		//Cycles = 440
     		StartTimeUsec = -2205000
     		//StartTimeUsec = 0
     		// Frequency = 50000
     		// This script is called upon entering run state, after having put the ADC in LLC mode
     		// it arms the ADC system end enters a wait trigger state
     		// CAUTION: in reprocessing the soft-trigger comes too early, for now
     		// arming must be done externally w.r.t. MARTe and the following line commented out
     		// CAUTION: the number of transient samples (samples after which the ADC goes back in idle state) is set in this script
     		
		// TODO: separate setup and arm, setup to be executed at MARTe statrup:
		RunScript = "/root/scd/commands/llc-run-thomson-arm" 
     		EndrunScript = "/root/scd/commands/llc-run-thomson-abort"
     		Signals = {
         		Counter = { // the sample (event in this case) counters from each ADC system
             		Type = int32
             		NumberOfElements = 4
         		}
         		Time = {    // the realtime maintained by the ADC subsystem, units [us]
             		Type = int32
             		Frequency = 1000 // Dummy data, here only to ask a synchronizing data broker to the framework
         		}
         		ADCuscounter = { // the sample (event in this case) timestamps from each ADC system [us]
         		    Type = uint32
         		    NumberOfElements = 4
         		}
         		ADCinputs = { // ADC inputs vector
             		Type = int16
             		NumberOfElements = 768
         		}
         	}
         	+TermMessage1 = { Class=Message Destination=StateMachine Function=RUNCOMPLETE }
     	}    
        +RTThreadSynch1 = {
            Class = RealTimeThreadSynchronisation
            Timeout = 1000 //Timeout in ms to wait for the thread to cycle.
        	//Timeout = 0
        } 
        +MDSWriter1 = {
        	Class = MDSWriter
			NumberOfBuffers = 100000
        	CPUMask = 0x04
        	StackSize = 10000000
        	TreeName = "martetest"
        	//StoreOnTrigger = 1
        	StoreOnTrigger = 0        	
        	Verbosity = 2
                
        	// Undefined, OpenTree is deferred, it is performed in response to a specific message sent by the ShotManager
        	// this is necessary because we need a late opening to have simulink buses configured
        	// the shotno is the parameter of the opening message
        	//PulseNumber = -2
        	PulseNumber = -1
          	
        	EventName = "updatejScope"
        	TimeRefresh = 5
        	NumberOfPreTriggers = 0
			NumberOfPostTriggers = 0
		
			Signals = {


//				Trigger 					= { Type = uint8 }	
//			    Time    					= { Type = int32 TimeSignal = 1 TimeSignalMultiplier = 1e-6 }
  
				Thread1_CycleTime    		= { NodeName = "ST.CH01" 	 	 Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 1 SamplePhase = 0 } 
				ADCBroker_Time    			= { NodeName = "ST.CH02" 	 	 Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 3 SamplePhase = 0 } 				
				StorageBroker1_Time        	= { NodeName = "ST.CH03" 	 	 Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 3 SamplePhase = 0 }				
	
				Counter 					= { NodeName = "ST.CH10" 	 	 Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 4 SamplePhase = 0 } 
				Time 						= { NodeName = "ST.CH11" 	 	 Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 1 SamplePhase = 0 } 
				ADCuscounter 				= { NodeName = "ST.CH12" 	 	 Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 4 SamplePhase = 0 } 

//				realadc      				= { NodeName = "AI.CH_%03d" 	 Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 768 SamplePhase = 0 Indexed = 1 } // Plain indexed entry (no multidimensional signal supported!)    	
// physical ADC order 
/*
				adc1      				    = { NodeName = "AI.CH001" 	     Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 1 SamplePhase = 0 } // Plain indexed entry (no multidimensional signal supported!)    	
				adc2      				    = { NodeName = "AI.CH002" 	     Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 1 SamplePhase = 0 } // Plain indexed entry (no multidimensional signal supported!)    	
				adc193      				= { NodeName = "AI.CH193" 	     Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 1 SamplePhase = 0 } // Plain indexed entry (no multidimensional signal supported!)    	
				adc385      				= { NodeName = "AI.CH385" 	     Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 1 SamplePhase = 0 } // Plain indexed entry (no multidimensional signal supported!)    	
				adc577      				= { NodeName = "AI.CH577" 	     Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 1 SamplePhase = 0 } // Plain indexed entry (no multidimensional signal supported!)    	
*/
// logical spectro order
				adc1      				    = { NodeName = "AI.CH001" 	     Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 1 SamplePhase = 0 } // Plain indexed entry (no multidimensional signal supported!)    	
				adc2      				    = { NodeName = "AI.CH005" 	     Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 1 SamplePhase = 0 } // Plain indexed entry (no multidimensional signal supported!)    	
				adc193      				= { NodeName = "AI.CH002" 	     Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 1 SamplePhase = 0 } // Plain indexed entry (no multidimensional signal supported!)    	
				adc385      				= { NodeName = "AI.CH003" 	     Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 1 SamplePhase = 0 } // Plain indexed entry (no multidimensional signal supported!)    	
				adc577      				= { NodeName = "AI.CH004" 	     Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 1 SamplePhase = 0 } // Plain indexed entry (no multidimensional signal supported!)    	
        	}
        	+TreeFlushedMsg = { Class = Message Destination = ShotManager Function = TreeFlushed Mode = ExpectsReply }
        }                      
    

        +MDSWriter2 = {
        	Class = MDSWriter
			NumberOfBuffers = 100000
        	CPUMask = 0x04
        	StackSize = 10000000
        	TreeName = "martetest"
        	//StoreOnTrigger = 1
        	StoreOnTrigger = 0        	
        	Verbosity = 2
        	// Undefined, OpenTree is deferred, it is performed in response to a specific message sent by the ShotManager
        	// this is necessary because we need a late opening to have simulink buses configured
        	// the shotno is the parameter of the opening message
        	//PulseNumber = -2
        	PulseNumber = 0
        	EventName = "updatejScope"
        	TimeRefresh = 5
        	NumberOfPreTriggers = 0
			NumberOfPostTriggers = 0
		
			Signals = {

//				Trigger 					= { Type = uint8 }	
//			    Time    					= { Type = int32 TimeSignal = 1 TimeSignalMultiplier = 1e-6 }
  
				Thread2_CycleTime    		= { NodeName = "ST.CH21" 	 	 Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 1 SamplePhase = 0 } 
				GAMSimulink2_Time    		= { NodeName = "ST.CH22" 	 	 Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 3 SamplePhase = 0 } 				
				StorageBroker2_Time        	= { NodeName = "ST.CH23" 	 	 Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 3 SamplePhase = 0 }				
	
				Counter 					= { NodeName = "ST.CH24" 	 	 Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 4 SamplePhase = 0 } 
				realtime 					= { NodeName = "ST.CH25" 	 	 Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 1 SamplePhase = 0 } 

                testep 					    = { NodeName = "ST.CH28" 	 	 Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 109 SamplePhase = 0 } 
				testeperr 					= { NodeName = "ST.CH29" 	 	 Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 109 SamplePhase = 0 } 
                nestep 					    = { NodeName = "ST.CH30" 	 	 Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 109 SamplePhase = 0 } 
				nesteperr 					= { NodeName = "ST.CH31" 	 	 Period = 1  MakeSegmentAfterNWrites = 600000 AutomaticSegmentation = 0 NumberOfElements = 109 SamplePhase = 0 } 
				
        	}
        	+TreeFlushedMsg = { Class = Message Destination = ShotManager Function = TreeFlushed Mode = ExpectsReply }
        }                      
    }
    
    
    +States = {
        Class = ReferenceContainer
        +Run = {
            Class = RealTimeState
            +Threads = {
                Class = ReferenceContainer
                +Thread1 = {
                    Class = RealTimeThread CPUs = 0x08 Functions = {
                      ADCBroker 
                      TimeSignals 
					  TimingSignalsBroker1
					  //LoggerBroker
					  StorageBroker1
					  T1TSynch
                    }
                }                                
                +Thread2 = {
                    Class = RealTimeThread CPUs = 0x10 Functions = {
                      T1T2Com
                      Constants 
					  SpectroRouter
					  //LoggerBroker
					  GAMSimulink2
					  TimingSignalsBroker2
					  StorageBroker2
                    }                                
                }                
            }
        }
    }          
    +Scheduler = {
        Class = GAMScheduler
        TimingDataSource = Timings
    }
}
