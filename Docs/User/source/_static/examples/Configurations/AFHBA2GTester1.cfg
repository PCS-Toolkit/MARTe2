/*
 AFHBA2G tester cfg on NODE07
 CGalperti 11.09.2020

 - test with state machine and transient auto termination
 - TCP message server to advance state machine
 - 1 thread 
 - MDS+ storage
*/

+ShotManager = {
 Class = SPCShotManager
 Server = tcvscd.crpp.tcv
 Tree = rtc_state
 Shot = -1
 Statusnode = NODESTATE.NODE07.STATUS
 AbortScript = "/root/generic/postshot"
 //+OpenTreeMsg = { Class = Message Destination = RTApp.Data.MDSWriter Function = OpenTree Mode = ExpectsReply +Parameters = { Class = ConfigurationDatabase param1 = 0 } }
}

+TCPMessageProxy = {
    Class = TCPSocketMessageProxyExample
    Port = 24680
}

+StateMachine = {
 Class = StateMachine
 +INITIAL = {
  Class = ReferenceContainer
  +RUN = {
   Class = StateMachineEvent
   NextState = "RUN"
   NextStateError = "ERROR"
   Timeout = 0
   +ChangeToRunMsg = { Class = Message Destination = RTApp Function = PrepareNextState Mode = ExpectsReply +Parameters = { Class = ConfigurationDatabase param1 = Run } }
   +StartNextStateExecutionMsg = { Class = Message Destination = RTApp Function = StartNextStateExecution Mode = ExpectsReply }
   +ShotManagerStartMsg = { Class = Message Destination = ShotManager Function = Run Mode = ExpectsReply }
  }
  +ERROR = {
   Class = StateMachineEvent
   NextState = "ERROR"
   NextStateError = "ERROR"
   Timeout = 0
   +ShotManagerErrorMsg = { Class = Message Destination = ShotManager Function = Error Mode = ExpectsReply }
  }
  +EXIT = {
   Class = StateMachineEvent
   NextState = "FINAL"
   NextStateError = "ERROR"
   Timeout = 0
   +ExitAppMsg = { Class = Message Destination = ShotManager Function = Exit }
  }
  +ABORT = {
   Class = StateMachineEvent
   NextState = "FINAL"
   NextStateError = "ERROR"
   Timeout = 0
   +ExitAppMsg = { Class = Message Destination = ShotManager Function = Exit }
  }
 }
 +RUN = {
  Class = ReferenceContainer
  +RUNCOMPLETE = {
   Class = StateMachineEvent
   NextState = "ENDRUN"
   NextStateError = "ERROR"
   Timeout = 0
   +StopCurrentStateExecutionMsg = { Class = Message Destination = RTApp Function = StopCurrentStateExecution Mode = ExpectsReply }
   +MdsFlushSegmentsMsg = { Class = Message Destination = RTApp.Data.MDSWriter Function = FlushSegments Mode = ExpectsReply }
   +ShotManagerStopMsg = { Class = Message Destination = ShotManager Function = Stop Mode = ExpectsReply }
  }
  +ABORT = {
   Class = StateMachineEvent
   NextState = "FINAL"
   NextStateError = "ERROR"
   Timeout = 0
   +StopLLCMsg = { Class = Message Destination = RTApp.Data.ADCSystem Function = StopLLC Mode = ExpectsReply }
   +StopCurrentStateExecutionMsg = { Class = Message Destination = RTApp Function = StopCurrentStateExecution Mode = ExpectsReply }
   +ShotManagerAbortMsg = { Class = Message Destination = ShotManager Function = Abort Mode = ExpectsReply }
  }
 }
 +ENDRUN = {
  Class = ReferenceContainer
  +ENTER = {
   Class = ReferenceContainer
  }
  +EXIT = {
   Class = StateMachineEvent
   NextState = "FINAL"
   NextStateError = "ERROR"
   Timeout = 0
   +ExitAppMsg = { Class = Message Destination = ShotManager Function = Exit }
  }
  +ABORT = {
   Class = StateMachineEvent
   NextState = "FINAL"
   NextStateError = "ERROR"
   Timeout = 0
   +ExitAppMsg = { Class = Message Destination = ShotManager Function = Exit }
  }
 }
 +FINAL = {
  Class = ReferenceContainer
  +FINAL = {
   Class = StateMachineEvent
   NextState = "FINAL"
   NextStateError = "ERROR"
   Timeout = 0
  }
 }
 +ERROR = {
  Class = ReferenceContainer
  +ENTER = {
   Class = ReferenceContainer
   +ShotManagerErrorMsg = { Class = Message Destination = ShotManager Function = Error Mode = ExpectsReply }
  }
  +EXIT = {
   Class = StateMachineEvent
   NextState = "FINAL"
   NextStateError = "ERROR"
   Timeout = 0
   +ExitAppMsg = { Class = Message Destination = ShotManager Function = Exit }
  }
 }
}


$RTApp = {
    Class = RealTimeApplication
    +Functions = {
        Class = ReferenceContainer
        +ADCBroker = {
            Class = IOGAM
            InputSignals = {
                Counter = 		{ DataSource = ADCSystem Type = int32 }
                Time =    		{ DataSource = ADCSystem Type = int32 Frequency = 1000 }
                BufferId =      { DataSource = ADCSystem Type = uint8 }
                ADCs = 	        { DataSource = ADCSystem Type = int16 NumberOfElements = 64 Samples = 256 } 
            }
            OutputSignals = {
                Counter = 		{ DataSource = DDB1 Type = int32 }
                Time =    		{ DataSource = DDB1 Type = int32 }
                BufferId =      { DataSource = DDB1 Type = uint8 }
                ADCbuffer = 	{ DataSource = DDB1 Type = int16 NumberOfElements = 16384 } 
            }
        }
        +MDSBroker = {
            Class = IOGAM            
            InputSignals = {
	            State1_Thread1_CycleTime = {		DataSource = Timings 	Type = uint32 	Alias = Run.Thread1_CycleTime }
                Counter  = {		  				DataSource = DDB1  		Type = int32 } 
				Time     = {                        DataSource = DDB1  		Type = int32 }
                BufferId = {                        DataSource = DDB1       Type = uint8 }
            
            } 
            OutputSignals = {
	            State1_Thread1_CycleTime = {		DataSource = MDSWriter 	Type = uint32}
                Counter  = {		  				DataSource = MDSWriter  Type = int32 } 
				Time     = {                        DataSource = MDSWriter  Type = int32 }
                BufferId = {                        DataSource = MDSWriter  Type = uint8 }
			}
        }
    }
    +Data = {
        Class = ReferenceContainer
        DefaultDataSource = DDB1
        +DDB1 				= { Class = GAMDataSource }        
        +LoggerDataSource 	= { Class = LoggerDataSource }
        +Timings 			= { Class = TimingDataSource }                
        +ADCSystem = {
 	    	Class = AFHBA2G::ACQ196RTMTN07IN
			Device = 0 // Userspace device entry to be opened
			NBuffers = 16
			BufferLen = 32768
			ExecutionMode = RealTimeThread //Optional. If not set ExecutionMode = IndependentThread. If ExecutionMode == IndependentThread a thread is spawned to generate the time events. ExecutionMode == RealTimeThread the time is generated in the context of the real-time thread.
			//CPUMask = 0x8 //Optional and only relevant if ExecutionMode=IndependentThread
     		Cycles = 100
     		StartTimeUsec = 0
     		// old HIC run scripts were (to be integrated here):
     		// /home/cristian/scripts/preparert.sh
     		// /root/generic/setup 100 110 500000 256000, the second parameter is the channel block mask, third and fourth not used anymore
     		// /root/generic/arm 
			//RunScript = "/root/generic/arm"
			//EndrunScript = "/root/generic/postshot"
            Signals = {
                Counter = {           // the cycle counter maintained by the ADC subsystem
                    Type = int32
                }
                Time = {              // the realtime maintained by the ADC subsystem, units [us]
                    Type = int32
                    Frequency = 1000  // The expected frequency of data production, see note (1)
                }
                BufferId = {
                    Type = uint8      // the last buffer id read
                }
                ADCs = {              // ADC inputs vector
                    Type = int16
                    NumberOfElements = 64 // See note (2)
                    Samples = 256 // See note (3)
                }
            }
         	+TermMessage1 = { Class=Message Destination=StateMachine Function=RUNCOMPLETE }
     	}                
        +MDSWriter = {
        	Class = MDSWriter::MDSWriter
			NumberOfBuffers = 100000
        	CPUMask = 0x04
        	StackSize = 10000000
        	TreeName = "martetest"
        	StoreOnTrigger = 0
        	PulseNumber = 1
        	EventName = "updatejScope"
        	TimeRefresh = 5
        	NumberOfPreTriggers = 0
			NumberOfPostTriggers = 0
			Signals = {
	            State1_Thread1_CycleTime = {		NodeName = "ST.CH01" Period = 1 MakeSegmentAfterNWrites = 25000 AutomaticSegmentation = 0 }
                Counter  = {		  				NodeName = "ST.CH02" Period = 1 MakeSegmentAfterNWrites = 25000 AutomaticSegmentation = 0 } 
				Time     = {                        NodeName = "ST.CH03" Period = 1 MakeSegmentAfterNWrites = 25000 AutomaticSegmentation = 0 }
                BufferId = {                        NodeName = "ST.CH04" Period = 1 MakeSegmentAfterNWrites = 25000 AutomaticSegmentation = 0 }
        	}
        }                
    }
    +States = {
        Class = ReferenceContainer
        +Run = {
            Class = RealTimeState
            +Threads = {
                Class = ReferenceContainer
                +Thread1 = { 
                	Class = RealTimeThread CPUs = 0x02
                	Functions = {
                	  ADCBroker 
                	  MDSBroker 
                	} 
                }
            }
        }
                    
    }
    +Scheduler = {
        Class = GAMScheduler
        TimingDataSource = Timings
    }
}
