/*
 Simulink tester cfg, hardware interface with AFHBA404, version arming and waiting the ADC
 Final shot version, CAUTION: ADC input not yet connected
 CGalperti 04.09.2019

 - 1 thread, AFHBA404 timing, transient auto termination 
 - state machine
 - TCP server for advancind state machine, ShotManager for sending status to MDS+ 
 - tunable parameters loading through MDSObjLoader
 - wavegen loading through MDSObjWavegen
 - previous ADC loading through MDSObjWavegen
 - MDS+ storage of algorithm outputs and timings
 - MDS+ simulink bus storage with names
 - DAC connected
*/

+ShotManager = {
 Class = SPCShotManager
 Server = crpppc171.epfl.ch
 Tree = rtc_state
 Shot = 1
 Statusnode = STATE
 AbortScript = "/root/generic/abort-ADC" 
 // The parameter param1 is the shotnumber to be opened 
 +OpenTreeMsg1 = { Class = Message Destination = RTApp.Data.MDSWriter Function = OpenTree Mode = ExpectsReply +Parameters = { Class = ConfigurationDatabase param1 = -1 } } 
 //+OpenTreeMsg1 = { Class = Message Destination = RTApp.Data.MDSWriter Function = OpenTree Mode = ExpectsReply +Parameters = { Class = ConfigurationDatabase param1 = 0 } }
}

+TCPMessageProxy = {
    Class = TCPSocketMessageProxyExample
    Port = 24680
}

/*
+LoggerService = {
      Class = LoggerService
      CPUs = 0x1 //Compulsory. The CPU mask where the asynchronous thread will run.
      StackSize = 32768 //Optional. The stack size of the asynchronous thread.
      NumberOfLogPages = 128 //Optional. The number of log pages.
	  +SysLogger = {
       Class = SysLogger
       Format = EFm //Compulsory. As described in LoggerConsumerI::LoadPrintPreferences
       PrintKeys = 0 //Optional. As described in LoggerConsumerI::LoadPrintPreferences
       Ident = SCDApp //Compulsory. Name of the syslog ident.
      }
      +ConsoleLogger = {
       Class = ConsoleLogger
       //Format = ETtOofFRmC //Compulsory. As described in LoggerConsumerI::LoadPrintPreferences
       Format = EFm //Compulsory. As described in LoggerConsumerI::LoadPrintPreferences
       PrintKeys = 0 //Optional. As described in LoggerConsumerI::LoadPrintPreferences
      }
      //+UDPLogger = {
      // Class = UDPLogger
      // Address = "127.0.0.1" //Compulsory. The address of the destination where the logs are to be sent to.
      // Port = 44444 //Compulsory. The port of the destination where the logs are to be sent to.
      // Format = EFm //Compulsory. As described in LoggerConsumerI::LoadPrintPreferences
      // PrintKeys = 0 //Optional. As described in LoggerConsumerI::LoadPrintPreferences
      //}
}
*/

+StateMachine = {
 Class = StateMachine
 +INITIAL = {
  Class = ReferenceContainer
  +RUN = {
   Class = StateMachineEvent
   NextState = "RUN"
   NextStateError = "ERROR"
   Timeout = 0
   +ChangeToRunMsg               = { Class = Message Destination = RTApp     Function = PrepareNextState Mode = ExpectsReply +Parameters = { Class = ConfigurationDatabase param1 = Run } }
   +StartNextStateExecutionMsg   = { Class = Message Destination = RTApp     Function = StartNextStateExecution Mode = ExpectsReply }
   +ShotManagerStartMsg 	     = { Class = Message Destination = ShotManager Function = Run Mode = ExpectsReply }
  }
  +ERROR = {
   Class = StateMachineEvent
   NextState = "ERROR"
   NextStateError = "ERROR"
   Timeout = 0
   +ShotManagerErrorMsg 	     = { Class = Message Destination = ShotManager Function = Error Mode = ExpectsReply }  
  }
  +EXIT = {
   Class = StateMachineEvent
   NextState = "FINAL"
   NextStateError = "ERROR"
   Timeout = 0
   +ExitAppMsg = { Class = Message Destination = ShotManager     Function = Exit }   
  }
  +ABORT = {
   Class = StateMachineEvent
   NextState = "FINAL"
   NextStateError = "ERROR"
   Timeout = 0
   +ExitAppMsg = { Class = Message Destination = ShotManager     Function = Exit }   
  }
 }
 +RUN = {
  Class = ReferenceContainer
  +RUNCOMPLETE = {
   Class = StateMachineEvent
   NextState = "ENDRUN"
   NextStateError = "ERROR"
   Timeout = 0
   +StopCurrentStateExecutionMsg = { Class = Message Destination = RTApp     			Function = StopCurrentStateExecution Mode = ExpectsReply }
   +MdsFlushSegmentsMsg          = { Class = Message Destination = RTApp.Data.MDSWriter Function = FlushSegments Mode = ExpectsReply }
   +ShotManagerStopMsg 			 = { Class = Message Destination = ShotManager 			Function = Stop Mode = ExpectsReply }
  }
  +ABORT = {
   Class = StateMachineEvent
   NextState = "FINAL"
   NextStateError = "ERROR"
   Timeout = 0
   +StopLLCMsg					   = { Class = Message Destination = RTApp.Data.ADCSystem  Function = StopLLC Mode = ExpectsReply }
   +StopCurrentStateExecutionMsg = { Class = Message Destination = RTApp     			Function = StopCurrentStateExecution Mode = ExpectsReply }
   //+MdsFlushSegmentsMsg          = { Class = Message Destination = RTApp.Data.MDSWriter Function = FlushSegments Mode = ExpectsReply }  
   +ShotManagerAbortMsg 		 = { Class = Message Destination = ShotManager 			Function = Abort Mode = ExpectsReply }
  }
 }
 +ENDRUN = {
  Class = ReferenceContainer
  +ENTER = {
   Class = ReferenceContainer
   //+StopCurrentStateExecutionMsg = { Class = Message Destination = RTApp     Function = StopCurrentStateExecution Mode = ExpectsReply }   
   //+ShotManagerStopMsg 			 = { Class = Message Destination = ShotManager Function = Stop Mode = ExpectsReply }
  }
  +EXIT = {
   Class = StateMachineEvent
   NextState = "FINAL"
   NextStateError = "ERROR"
   Timeout = 0
   +ExitAppMsg = { Class = Message Destination = ShotManager     Function = Exit }   
  }
  +ABORT = {
   Class = StateMachineEvent
   NextState = "FINAL"
   NextStateError = "ERROR"
   Timeout = 0
   +ExitAppMsg = { Class = Message Destination = ShotManager     Function = Exit }   
  }
 } 
 +FINAL = {
  Class = ReferenceContainer
  +FINAL = {
   Class = StateMachineEvent
   NextState = "FINAL"
   NextStateError = "ERROR"
   Timeout = 0   
  } 
 }
 +ERROR = {
  Class = ReferenceContainer  
  +ENTER = {
   Class = ReferenceContainer
   +ShotManagerErrorMsg = { Class = Message Destination = ShotManager     Function = Error Mode = ExpectsReply }   
  }  
  +EXIT = {
   Class = StateMachineEvent
   NextState = "FINAL"
   NextStateError = "ERROR"
   Timeout = 0
   +ExitAppMsg = { Class = Message Destination = ShotManager     Function = Exit }   
  }
 }
}


+MDSParameters = {
 Class=MDSObjLoader
 Shot=53600
 +Connection_tcvdata_tcv_shot = {
  Class=MDSObjConnection
  Server=tcvdata.epfl.ch
  Tree=tcv_shot
  +SCDnode02_tp-ADCgains-Ain_gains                    = { Class=MDSParVector                   Path="\\hybrid::mat_a_in_scale"               }
  +SCDnode02_tp-ADCgains-DML_gain1                    = { Class=MDSParScalar                   Path="\\DIAGZ::DML_VLOOP:DCL1COIL.gain"       }
  +SCDnode02_tp-ADCgains-DML_gain2                    = { Class=MDSParScalar                   Path="\\DIAGZ::DML_VLOOP:DBRIPPLECOIL.gain"   }
  +SCDnode02_tp-ADCgains-DML_gain3                    = { Class=MDSParScalar                   Path="\\DIAGZ::DML_FLUX:CLCOIL.gain"          }
  +SCDnode02_tp-ADCgains-DML_gain4                    = { Class=MDSParScalar                   Path="\\DIAGZ::DML_FLUX:DML2AMPF.gain"        }
  +SCDnode02_tp-ADCgains-RVLOOP_gains                 = { Class=MDSParVector                   Path="\\MAGNETICS::RVLOOP.gain"               }
  +SCDnode02_tp-DACgains-OUT_scale_e_u                = { Class=MDSParScalar                   Path="\\hybrid::output_scales_e_u"            }
  +SCDnode02_tp-DACgains-OUT_scale_f_u                = { Class=MDSParScalar                   Path="\\hybrid::output_scales_f_u"            }
  +SCDnode02_tp-DACgains-OUT_scale_oh_u               = { Class=MDSParScalar                   Path="\\hybrid::output_scales_oh_u"           }
  +SCDnode02_tp-DACgains-OUT_scale_gas                = { Class=MDSParScalar                   Path="\\hybrid::output_scales_gas"            }
  +SCDnode02_tp-DACgains-OUT_scale_fast_u             = { Class=MDSParScalar                   Path="\\hybrid::output_scales_fast_u"         }
  +SCDnode02_tp-DACgains-OUT_scale_e_i                = { Class=MDSParScalar                   Path="\\hybrid::output_scales_e_i"            }
  +SCDnode02_tp-DACgains-OUT_scale_f_i                = { Class=MDSParScalar                   Path="\\hybrid::output_scales_f_i"            }
  +SCDalgo_02stddiag_tp-ADCpre-T_F_R                  = { Class=MDSParMatrix                   Path="\\MAGNETICS::VIRT.T_F_R"                }
  +SCDalgo_02stddiag_tp-ADCpre-t_start_bphi           = { Class=MDSParScalar                   Path="vdbget('powerdb::shot_design:bphi_start_ref')" }
  +SCDalgo_02stddiag_tp-ADCpre-t_start_bpol           = { Class=MDSParScalar                   Path="vdbget('powerdb::shot_design:pol_start_ref')" }
  +SCDalgo_02stddiag_tp-DMLpre-c_fix_tor_nonlin       = { Class=MDSParScalar                   Path="\\results::dmlbo002:c"                  }
  +SCDalgo_02stddiag_tp-DMLpre-c_fix_tor_diff         = { Class=MDSParScalar                   Path="\\results::dmlbo004:c"                  }
  +SCDalgo_02stddiag_tp-DMLpre-p_var_tor_ferro        = { Class=MDSParScalar                   Path="\\results::dmlbo005:p"                  }
  +SCDalgo_02stddiag_tp-DMLpre-c_fix_pol_lin          = { Class=MDSParVector                   Path="\\results::dmlbo006:c"                  }
  +SCDalgo_02stddiag_tp-DMLpre-c_fix_def              = { Class=MDSParVector                   Path="\\results::dmlbo007:c"                  }
  +SCDalgo_02stddiag_tp-DMLpre-c_fix_pol_vessel       = { Class=MDSParVector                   Path="\\results::dmlbo008:c"                  }
  +SCDalgo_hybrid_tp-A_matrix                         = { Class=MDSParMatrix                   Path="\\pcs::phys_mat_a"                      }
  +SCDalgo_hybrid_tp-M_matrix                         = { Class=MDSParMatrix                   Path="\\pcs::phys_mat_m"                      }
  +SCDalgo_hybrid_tp-G1_matrix                        = { Class=MDSPar3DMatrix                 Path="\\pcs::phys_mat_g1"                     }
  +SCDalgo_hybrid_tp-G2_matrix                        = { Class=MDSPar3DMatrix                 Path="\\pcs::phys_mat_g2"                     }
  +SCDalgo_hybrid_tp-G3_matrix                        = { Class=MDSPar3DMatrix                 Path="\\pcs::phys_mat_g3"                     }
  +SCDalgo_hybrid_tp-G_time                           = { Class=MDSParFixDimVector             Path="dim_of(\\pcs::phys_mat_addresses:G)"    Dim=50 }
  +SCDalgo_hybrid_tp-G_order                          = { Class=MDSParFixDimVectorInt          Path="\\pcs::phys_mat_addresses:G"            Dim=50 }
  +SCDalgo_hybrid_tp-WG_start_time                    = { Class=MDSParFixDimVectorIdx          Path="dim_of(\\\\draw_refs:ref_%03d)[0]"      StartIdx=1 StopIdx=24 }
  +SCDalgo_hybrid_tp-mgams-mvloop                     = { Class=MDSParScalarInt                Path="\\pcs::mgams.data:mvloop"               }
  +SCDalgo_hybrid_tp-mgams-ierat                      = { Class=MDSParScalarInt                Path="\\pcs::mgams.data:ierat"                }
  +SCDalgo_hybrid_tp-mgams-ikriz                      = { Class=MDSParScalarInt                Path="\\pcs::mgams.data:ikriz"                }
  +SCDalgo_hybrid_tp-mgams-inova                      = { Class=MDSParScalarInt                Path="\\pcs::mgams.data:inova"                }
  +SCDalgo_hybrid_tp-mgams-nfast                      = { Class=MDSParScalarInt                Path="\\pcs::mgams.data:nfast"                }
  +SCDalgo_hybrid_tp-ensignbits                       = { Class=MDSParScalarInt                Path=""                                       }
  +SCDalgo_hybrid_tp-endigdens1                       = { Class=MDSParScalarInt                Path=""                                       }
  +SCDalgo_signbits_tp-A_matrix                       = { Class=MDSParMatrix                   Path="\\pcs::phys_mat_a"                      }
  +SCDalgo_digdensityctrl1_tp-dneon                   = { Class=MDSParScalarInt                Path="\\pcs::mgams.data:dneon"                }
  +SCDalgo_digdensityctrl1_tp-dnekp                   = { Class=MDSParScalar                   Path="\\pcs::mgams.data:dnekp"                }
  +SCDalgo_digdensityctrl1_tp-dneki                   = { Class=MDSParScalar                   Path="\\pcs::mgams.data:dneki"                }
  +SCDalgo_digdensityctrl1_tp-dnekd                   = { Class=MDSParScalar                   Path="\\pcs::mgams.data:dnekd"                }
  +SCDalgo_digdensityctrl1_tp-dneka                   = { Class=MDSParScalar                   Path="\\pcs::mgams.data:dneka"                }
  +SCDalgo_digdensityctrl1_tp-dnefil                  = { Class=MDSParScalar                   Path="\\pcs::mgams.data:dnefil"               }
  +SCDalgo_digdensityctrl1_tp-dnemode                 = { Class=MDSParScalarInt                Path="\\pcs::mgams.data:dnemode"              }
  +SCDalgo_digdensityctrl1_tp-dnescal1                = { Class=MDSParScalar                   Path="\\pcs::mgams.data:dnescal1"             }
  +SCDalgo_digdensityctrl1_tp-dnescal2                = { Class=MDSParScalar                   Path="\\pcs::mgams.data:dnescal2"             }
  +SCDalgo_digdensityctrl1_tp-dne1mm                  = { Class=MDSParScalar                   Path=""                                       }
  +SCDalgo_digdensityctrl1_tp-dnetlh                  = { Class=MDSParScalar                   Path=""                                       }
 }
}

$RTApp = {
    Class = RealTimeApplication
    +Functions = {
        Class = ReferenceContainer
        
        +ADCBroker = {
            Class = IOGAM
            InputSignals = {
                Counter      = {                   DataSource = ADCSystem Type = uint32 }                
                Time         = { Frequency = 10000 DataSource = ADCSystem Type = int32 }
            	ADCuscounter = {                   DataSource = ADCSystem Type = uint32 }
                ADCinputs    = {                   DataSource = ADCSystem Type = int16 NumberOfElements = 192 }
            }
            OutputSignals = {
                Counter      = {                   DataSource = DDB1  Type = uint32 }                
                Time         = {                   DataSource = DDB1  Type = int32 }      
                ADCuscounter = {                   DataSource = DDB1  Type = uint32 }
                realadc      = {                   DataSource = DDB1  Type = int16 NumberOfElements = 192 }   
            }
        }       
        
        +TestSignals1 = {
        	Class = HelperGAM1
        	        	
        	MdsTimeOffset = 0
        	MdsStartTime = -4495000
        	MdsStopTime = 3950000
        	
        	InputSignals = { 
        		Time  = 		{ DataSource = DDB1     Type = int32 }
        	}
        	OutputSignals = {
				realtime			= { DataSource = DDB1 Type = float32  NumberOfElements = 1   }   	
            	adc  				= { DataSource = DDB1 Type = int16    NumberOfElements = 192 }
				rfm_in      		= { DataSource = DDB1 Type = uint8    NumberOfElements = 664 }
				wavegen     		= { DataSource = DDB1 Type = float32  NumberOfElements = 62  }
				proc_in     		= { DataSource = DDB1 Type = float32  NumberOfElements = 3  }
				offsettimeforMDS	= { DataSource = DDB1 Type = int32 	  NumberOfElements = 1 }
		  		triggerforMDS 		= { DataSource = DDB1 Type = uint8    NumberOfElements = 1 }
                DOs 				= { DataSource = DDB1 Type = uint8    NumberOfElements = 4 }
                PWMduty 			= { DataSource = DDB1 Type = uint16   NumberOfElements = 8 } 
        	}
        }
        
        +WavegenTimeBroker1 = {
         Class = IOGAM
         InputSignals = { Time = { DataSource = DDB1 Type = int32 } }
         OutputSignals = { time = { DataSource = MDSWavegen_WG0202bus Type = int32 } }
        }                   
        +WavegenBroker1 = {
         Class = IOGAM
         InputSignals = {
           wavegen_WG0202bus = { DataSource = MDSWavegen_WG0202bus Type = float32 NumberOfElements = 62}
         }
         OutputSignals = {
           realwavegen = { DataSource = DDB1 Type = float32 NumberOfElements = 62 }
         }
        }
        
        +WavegenTimeBroker2 = {
         Class = IOGAM
         InputSignals = { Time = { DataSource = DDB1 Type = int32 } }
         OutputSignals = { time = { DataSource = MDSWavegen_ADC02bus Type = int32 } }
        }                   
        +WavegenBroker2 = {
         Class = IOGAM
         InputSignals = {
           wavegen_ADC02bus = { DataSource = MDSWavegen_ADC02bus Type = int16 NumberOfElements = 192}
         }
         OutputSignals = {
           wavegenadc = { DataSource = DDB1 Type = int16 NumberOfElements = 192 }
         }
        }
         
		+GAMSimulink = {
 			Class = SimulinkWrapperGAM
			Library = "/home/dt100/simulinkcodegen/SCD_rtccode_02_02.so"
			SymbolPrefix = "SCD_rtccode_02_02"
			Verbosity = 1
			TunParSourceGAM = MDSParameters
			SkipNotOkTunParams = 0
			InputSignals = {		
				realtime	= { DataSource = DDB1 Type = float32  NumberOfElements = 1   CheckSimulinkType = true  NumberOfDimensions=1 }
            	//adc  		= { DataSource = DDB1 Type = int16    NumberOfElements = 192 CheckSimulinkType = true  NumberOfDimensions=1 }
            	adc  		= { DataSource = DDB1 Type = int16    NumberOfElements = 192 CheckSimulinkType = true  NumberOfDimensions=1 Alias = wavegenadc }
				rfm_in      = { DataSource = DDB1 Type = uint8    NumberOfElements = 664 CheckSimulinkType = false NumberOfDimensions=1 }
				wavegen     = { DataSource = DDB1 Type = float32  NumberOfElements = 62  CheckSimulinkType = true  NumberOfDimensions=1 Alias = realwavegen }
				//wavegen     = { DataSource = DDB1 Type = float32  NumberOfElements = 62  CheckSimulinkType = true  NumberOfDimensions=1 }				
				proc_in     = { DataSource = DDB1 Type = float32  NumberOfElements = 3   CheckSimulinkType = false NumberOfDimensions=1 }
 			
 			}
 			OutputSignals = { 
				dac			= { DataSource = DDB1 Type = int16    NumberOfElements = 64  CheckSimulinkType = true  NumberOfDimensions=1 }		
				//mem         = { DataSource = DDB1 Type = float32  NumberOfElements = 32  CheckSimulinkType = true  NumberOfDimensions=1 }
				mem         = { DataSource = DDB1 Type = uint8  NumberOfElements = 156  CheckSimulinkType = false  NumberOfDimensions=1 }				
				DO          = { DataSource = DDB1 Type = uint8    NumberOfElements = 4   CheckSimulinkType = true  NumberOfDimensions=1 }
				rfm_out     = { DataSource = DDB1 Type = uint8    NumberOfElements = 640 CheckSimulinkType = false NumberOfDimensions=1 }
				proc_out    = { DataSource = DDB1 Type = float32  NumberOfElements = 1   CheckSimulinkType = false NumberOfDimensions=1 }
				info        = { DataSource = DDB1 Type = uint8	  NumberOfElements = 16  CheckSimulinkType = false NumberOfDimensions=1 }
			}
			+SimulinkReadyMsg = { Class = Message Destination = RTApp.Data.MDSWriter Function = SetupBusSignals Mode = ExpectsReply +Parameters = { Class = ConfigurationDatabase param1 = RTApp.Functions.GAMSimulink } }			
		}
	
				   
    	+TimingSignalsBroker = {
         Class = IOGAM
         InputSignals = { 
         	Thread1_CycleTime    			= { DataSource = Timings Type = uint32 Alias = Run.Thread1_CycleTime }
	        ADCBroker_ExecTime    			= { DataSource = Timings Type = uint32 } //2
	        TestSignals1_ExecTime    		= { DataSource = Timings Type = uint32 } //3
	        WavegenTimeBroker1_ExecTime   	= { DataSource = Timings Type = uint32 } //4
	        WavegenBroker1_ExecTime 		= { DataSource = Timings Type = uint32 } //5
	        WavegenTimeBroker2_ExecTime 	= { DataSource = Timings Type = uint32 } //6
	        WavegenBroker2_ExecTime 		= { DataSource = Timings Type = uint32 } //7
	        GAMSimulink_ExecTime 			= { DataSource = Timings Type = uint32 } //8
	        StorageBroker1_ExecTime       	= { DataSource = Timings Type = uint32 } //9
	        LoggerBroker_ExecTime 			= { DataSource = Timings Type = uint32 } //10

         }
         OutputSignals = { 
         	Thread1_CycleTime    			= { DataSource = DDB1 Type = uint32 } //1       
	        ADCBroker_ExecTime    			= { DataSource = DDB1 Type = uint32 } //2
	        TestSignals1_ExecTime    		= { DataSource = DDB1 Type = uint32 } //3
	        WavegenTimeBroker1_ExecTime   	= { DataSource = DDB1 Type = uint32 } //4
	        WavegenBroker1_ExecTime 		= { DataSource = DDB1 Type = uint32 } //5
	        WavegenTimeBroker2_ExecTime 	= { DataSource = DDB1 Type = uint32 } //6
	        WavegenBroker2_ExecTime 		= { DataSource = DDB1 Type = uint32 } //7
	        GAMSimulink_ExecTime 			= { DataSource = DDB1 Type = uint32 } //8
	        StorageBroker1_ExecTime       	= { DataSource = DDB1 Type = uint32 } //9
	        LoggerBroker_ExecTime 			= { DataSource = DDB1 Type = uint32 } //10
         }
        }                   
    	
    	+DACBroker = {
        	Class = IOGAM
            InputSignals = {
				dac        = {		   DataSource = DDB1 Type = int16 NumberOfElements = 64 }
				DOs        = {         DataSource = DDB1 Type = uint8 NumberOfElements = 4 }        	
        		PWMduty    = {         DataSource = DDB1  Type = uint16 NumberOfElements = 8 }
        	}
        	OutputSignals  = {
				DACoutputs = {		   DataSource = DACSystem Type = int16 NumberOfElements = 64 }
				DOs        = {         DataSource = DACSystem Type = uint8 NumberOfElements = 4 }        	
        		PWMduty    = {         DataSource = DACSystem Type = uint16 NumberOfElements = 8 }        	
        	}
        }
    			
		+StorageBroker1 = {
		 Class = IOGAM
		 InputSignals = {	  
		  triggerforMDS = { DataSource = DDB1 Type = uint8 }
		  offsettimeforMDS = { DataSource = DDB1 Type = int32 } 
          
          dac = { DataSource = DDB1 Type = int16 }
          mem = { DataSource = DDB1 Type = uint8 }
          
	      Thread1_CycleTime 			= { DataSource = DDB1 Type = uint32 } //1	 
	      ADCBroker_ExecTime    		= { DataSource = DDB1 Type = uint32 } //2
	      TestSignals1_ExecTime    		= { DataSource = DDB1 Type = uint32 } //3
	      WavegenTimeBroker1_ExecTime   = { DataSource = DDB1 Type = uint32 } //4
	      WavegenBroker1_ExecTime 		= { DataSource = DDB1 Type = uint32 } //5
	      WavegenTimeBroker2_ExecTime 	= { DataSource = DDB1 Type = uint32 } //6
	      WavegenBroker2_ExecTime 		= { DataSource = DDB1 Type = uint32 } //7
	      GAMSimulink_ExecTime 			= { DataSource = DDB1 Type = uint32 } //8
	      StorageBroker1_ExecTime       = { DataSource = DDB1 Type = uint32 } //9
	      LoggerBroker_ExecTime 		= { DataSource = DDB1 Type = uint32 } //10
		  ADCuscounter                  = { DataSource = DDB1 Type = uint32 } //11
		 		  
		  //realwavegen = { DataSource = DDB1 Type = float32 Ranges = {{0,23}} }
		 }
		 OutputSignals = {
		  Trigger = { DataSource = MDSWriter Type = uint8 }
		  Time = { DataSource = MDSWriter Type = int32 }
                    
		  dac  = 	{ DataSource = MDSWriter Type = int16   NumberOfElements = 64 }
		  mem  = 	{ DataSource = MDSWriter Type = uint8   NumberOfElements = 156 }
		  
		  st   = 	{ DataSource = MDSWriter Type = uint32  NumberOfelements = 10 }		 
		  		 
		  //test = { DataSource = MDSWriter Type = float32 NumberOfElements = 24 } 
		 }
		}
			
		+LoggerBroker = {
		 Class = IOGAM
		 InputSignals = {
		 	//Counter = 	{ DataSource = DDB1 Type = uint32 }
		 	Time    = 		{ DataSource = DDB1 Type = int32 }
		 	//realwavegen = { DataSource = DDB1 Type = float32 Ranges = {{0,0}} }
		 	realtime = 		{ DataSource = DDB1 Type = float32 }
		 }
		 OutputSignals =
		 {
		    //Counter = 	{ DataSource = LoggerDataSource Type = uint32 }
		    Time    = 		{ DataSource = LoggerDataSource Type = int32 }
		    //wavegen1 = 	{ DataSource = LoggerDataSource Type = float32 }
		    realtime = 		{ DataSource = LoggerDataSource Type = float32 }
		 }
		} 
		
    }
    +Data = {
        Class = ReferenceContainer
        DefaultDataSource = DDB1
        
        +DDB1 = {
            Class = GAMDataSource
       	}

        +LoggerDataSource = {
            Class = LoggerDataSource
        }
               
        +Timings = {
            Class = TimingDataSource
        }
        
        /*
        +Timer = {
            //Class = LinuxTimer
            Class = LinuxTimer::TerminatorLinuxTimer
            SleepNature = "Busy"
            //SleepNature = "Default"
            //ExecutionMode = RealTimeThread
            ExecutionMode = IndependentThread
            CPUMask = 0x04
            IncrementsPerCycle = 100 // If not defined it is taken from the configured Timer frequency
            StartTime=-1.0 // If not set starttime is 0
            StopTime=4.0 // If not set runs indefinitely
            //StopTime=-0.999 // If not set runs indefinitely
            
            SkipTimer=0 // If 1 runs at maximum possible speed w/o using any timer at all 
            Signals = { 
                Counter = { Type = uint32 }
                Time = { Type = int32 }
            }
            +TermMessage1 = { Class=Message Destination=StateMachine Function=RUNCOMPLETE }
            //+TermMessage2 = { Class=Message Destination=RTApp Function=StopCurrentStateExecution }
        }
        */
                
        +ADCSystem = {
 	    	Class = AFHBA404
			Personality = ACQ2106N02IN // TCV SCD node 02 input adc
			Device = 0 // Userspace device entry to be opened
			// TODO: IndependentThread isn't working, thread semaphore not handled by Execute, to be fixed
			ExecutionMode = RealTimeThread //Optional. If not set ExecutionMode = IndependentThread. If ExecutionMode == IndependentThread a thread is spawned to generate the time events. ExecutionMode == RealTimeThread the time is generated in the context of the real-time thread.
			//CPUMask = 0x8 //Optional and only relevant if ExecutionMode=IndependentThread
     		Cycles = 75000
     		StartTimeUsec = -4500000
     		Frequency = 10000
     		// This script is called upon entering run state, after having put the ADC in LLC mode
     		// it arms the ADC system end enters a wait trigger state
     		// CAUTION: in reprocessing the soft-trigger comes too early, for now
     		// arming must be done externally w.r.t. MARTe and the following line commented out
     		// CAUTION: the number of transient samples (samples after which the ADC goes back in idle state) is set in this script
     		RunScript = "/root/generic/arm-ADC" 
     		EndrunScript = "/root/generic/checkstop-ADC"
     		Signals = {
         		Counter = { // the sample counter maintained by the ADC subsystem
             		Type = uint32
         		}
         		Time = {    // the realtime maintained by the ADC subsystem, units [us]
             		Type = int32
             		Frequency = 10000
         		}
         		ADCuscounter = { // the us cycle counter maintained by the ADC, useful to debug ADC clocking issues
         		    Type = uint32
         		}
         		ADCinputs = { // ADC inputs vector
             		Type = int16
             		NumberOfElements = 192
         		}
         	}
         	+TermMessage1 = { Class=Message Destination=StateMachine Function=RUNCOMPLETE }
     	}
     	
        +DACSystem = {
 	    	Class = AFHBA404
			Personality = ACQ2106N02OUT // TCV SCD node 02 input adc
			Device = 1 // Userspace device entry to be opened
			// TODO: IndependentThread isn't working, thread semaphore not handled by Execute, to be fixed
			ExecutionMode = RealTimeThread //Optional. If not set ExecutionMode = IndependentThread. If ExecutionMode == IndependentThread a thread is spawned to generate the time events. ExecutionMode == RealTimeThread the time is generated in the context of the real-time thread.
			//CPUMask = 0x8 //Optional and only relevant if ExecutionMode=IndependentThread
		    Signals = {
		         DACoutputs = { // DAC outputs vector
		             Type = int16
		             NumberOfElements = 64
		         }
		         DOs = { // DO outputs vector
		             Type = uint8
		             NumberOfElements = 4
		         }
		         PWMduty = { // Duty cycle of PWM generators
		             Type = uint16
		             NumberOfElements = 8
		         }
		    }
     	}   
     	      
		+MDSWavegen_WG0202bus = {
		 Class = MDSObjWavegen
		 Shot = 53600
		 //Shot = 63495
		 Frequency = 10000.00
		 Server=tcvdata.epfl.ch
		 Tree=tcv_shot
		 Verbosity = 0
		 Interpolation = 1
		 TimeOffset = 0.0
		 +hyb_A_matrix_ref                                   = { Class=MDSWgSigArray1                 Path="\\draw_refs:ref_%03d"                   StartIdx=1 StopIdx=24 }		 
		 +hyb_FF_e_u                                         = { Class=MDSWgSigArray1                 Path="\\draw_feedfor_e_u:alim_%03d"           StartIdx=1 StopIdx=8 }
		 +hyb_FF_f_u                                         = { Class=MDSWgSigArray1                 Path="\\draw_feedfor_f_u:alim_%03d"           StartIdx=1 StopIdx=8 }
		 +hyb_FF_oh_u                                        = { Class=MDSWgSigArray1                 Path="\\draw_feedfor_oh_u:alim_%03d"          StartIdx=1 StopIdx=2 }
		 +hyb_FF_gas                                         = { Class=MDSWgSigArray1                 Path="\\draw_feedfor_gas:alim_%03d"           StartIdx=1 StopIdx=4 }
		 +hyb_FF_e_i                                         = { Class=MDSWgSigArray1                 Path="\\draw_feedfor_e_i:alim_%03d"           StartIdx=1 StopIdx=8 }
		 +hyb_FF_f_i                                         = { Class=MDSWgSigArray1                 Path="\\draw_feedfor_f_i:alim_%03d"           StartIdx=1 StopIdx=8 }
		 Signals = {
		   time = { Type = int32 }
		   wavegen_WG0202bus = { Type = float32 NumberOfElements = 62 }	 
		 }	
		} 
		
		+MDSWavegen_ADC02bus = {
		 Class = MDSObjWavegen
		 Shot = 53600
		 Frequency = 10000.00
		 Server=scd.epfl.ch
		 Tree=rtc
		 Verbosity = 0
		 Interpolation = 0
		 TimeOffset = 0.0
		 +adc02_board1                                       = { Class=MDSWgSigArray1Int16ACQ196Reorder            Path="\\top.crpprt02.board1.adc_%02d:raw" Timepath="\\top.crpprt02.board1.adc_%02d" PeriodPath="\\top.crpprt02.params:d_time" StartIdx=1 StopIdx=96 }
		 +adc02_board2                                       = { Class=MDSWgSigArray1Int16ACQ196Reorder            Path="\\top.crpprt02.board2.adc_%02d:raw" Timepath="\\top.crpprt02.board2.adc_%02d" PeriodPath="\\top.crpprt02.params:d_time" StartIdx=1 StopIdx=96 }		
		 Signals = {
		   time = { Type = int32 }
		   wavegen_ADC02bus = { Type = int16 NumberOfElements = 192 }
		 }
		}

        +MDSWriter = {
        	Class = MDSSPCWriter
			NumberOfBuffers = 100000
        	CPUMask = 0x10
        	StackSize = 10000000
        	//TreeName = "martetest"
        	TreeName = "rtc2"
        	StoreOnTrigger = 1
        	Verbosity = 0
        
        	// New shot requested
        	//PulseNumber = -1 
        
        	// Undefined, OpenTree is deferred, it is performed in response to a specific message sent by the ShotManager
        	// this is necessary because we need a late opening to have simulink buses configured
        	// the shotno is the parameter of the opening message
        	PulseNumber = -2 
          	
        	EventName = "updatejScope"
        	TimeRefresh = 5
        	NumberOfPreTriggers = 1
			NumberOfPostTriggers = 1
		
			Signals = {
				Trigger = { Type = uint8 }	
			    Time    = { Type = int32 TimeSignal = 1 TimeSignalMultiplier = 1e-6 }
  
			    dac     = { NodeName = "TCVRT02.DAC.DAC_%03d.RAW"       Indexed = 1 BusSrc = RTApp.Functions.GAMSimulink BusName = dac NamePath = ".-.NAME" Period = 0.0001  MakeSegmentAfterNWrites = 100000 AutomaticSegmentation = 0 NumberOfElements = 64 SamplePhase = 0 }	
				mem		= { NodeName = "TCVRT02.THREAD1.MEMS.MEM_%03d"  Indexed = 1 BusSrc = RTApp.Functions.GAMSimulink BusName = mem NamePath = ".NAME" Period = 0.0001  MakeSegmentAfterNWrites = 100000 AutomaticSegmentation = 0 NumberOfElements = 156 SamplePhase = 0 }
				st      = { NodeName = "TCVRT02.TSTATS.STAT_%03d" 	    Indexed = 1 Period = 0.0001  MakeSegmentAfterNWrites = 100000 AutomaticSegmentation = 0 NumberOfElements = 11 SamplePhase = 0 }    	
				
        		//test 	= { NodeName = "TCVRT02.TSTATS.STAT_020"  					Period = 0.0001  MakeSegmentAfterNWrites = 100000 AutomaticSegmentation = 0 NumberOfElements = 24 SamplePhase = 0 } 
        	}
        	+TreeFlushedMsg = { Class = Message Destination = ShotManager Function = TreeFlushed Mode = ExpectsReply }
        }                
    }
    +States = {
        Class = ReferenceContainer
        +Run = {
            Class = RealTimeState
            +Threads = {
                Class = ReferenceContainer
                +Thread1 = {
                    Class = RealTimeThread CPUs = 0x02 Functions = {ADCBroker WavegenTimeBroker1 WavegenTimeBroker2 WavegenBroker1 WavegenBroker2 TestSignals1 GAMSimulink TimingSignalsBroker DACBroker StorageBroker1}                                
                }
            }
        }
                
    }
    +Scheduler = {
        Class = GAMScheduler
        TimingDataSource = Timings
    }
}
